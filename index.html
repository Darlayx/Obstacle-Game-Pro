<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hindari Rintangan Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Variables for easier theme management */
            --ui-background-color: rgba(255, 255, 255, 0.5); /* Semi-transparent white */
            --ui-text-color: #1A202C; /* Very dark gray for high contrast */
            --ui-border-radius-large: 10px; 
            --ui-border-radius-small: 8px; 
            --ui-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);

            --hp-color-safe: #48BB78; /* Green */
            --hp-color-warning: #F6E05E; /* Yellow */
            --hp-color-critical: #F56565; /* Red */
            --armor-color: #4299E1; /* Blue */
            --resilience-color: #CD7F32; /* Bronze */
            --ultimate-charge-color: #9F7AEA; /* Purple */
            --ultimate-charge-inactive-color: #A0AEC0; /* Gray for inactive icons */
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f7fafc; /* Light gray background to frame the game */
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            font-family: 'Poppins', sans-serif; 
            padding-top: 2vh; 
        }
        #gameContainer {
            position: relative;
            width: 90vw; 
            max-width: 650px; 
            aspect-ratio: 9 / 18; 
            background-color: #FFFFFF; /* White container */
            border-radius: 28px;
            box-shadow: 0 16px 32px rgba(0,0,0,0.12), 0 6px 12px rgba(0,0,0,0.08);
            overflow: hidden; 
            border: 1px solid rgba(0,0,0,0.03);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 28px; 
            background-color: #FFFFFF; /* Pure white game screen background */
        }
        
        /* --- HUD / UI Styling --- */
        .ui-text-container { 
            position: absolute;
            top: 12px; 
            left: 12px;
            right: 12px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; 
            gap: 8px; /* Reduced gap between columns */
        }
        .ui-column {
            display: flex;
            flex-direction: column;
            gap: 6px; /* Reduced gap between elements */
            flex-basis: 0; 
            flex-grow: 1;
        }
        .ui-column.left { align-items: flex-start; }
        .ui-column.right { align-items: flex-end; }

        .ui-element { 
            font-weight: 600; /* Bolder font */
            padding: 5px 10px; /* Compact padding */
            border-radius: var(--ui-border-radius-large); 
            box-shadow: var(--ui-shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px); /* Blur effect */
            -webkit-backdrop-filter: blur(8px);
            display: flex; 
            align-items: center;
            gap: 6px; 
            background-color: var(--ui-background-color);
            color: var(--ui-text-color);
            /* Refined transition for all UI elements */
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        #hpContainer, #score {
            padding: 6px 12px;
            font-size: clamp(15px, 2.5vw, 17px);
        }

        #armorContainer, #resilienceContainer, #highScore, #ultimateContainer {
            padding: 4px 8px;
            font-size: clamp(11px, 1.9vw, 13px);
            border-radius: var(--ui-border-radius-small);
        }
        
        #hpContainer {
            min-width: 130px; 
        }
        /* HP status colors with updated transparency */
        #hpContainer.status-safe { background-color: rgba(72, 187, 120, 0.5); color: white; }
        #hpContainer.status-warning { background-color: rgba(246, 224, 94, 0.75); color: var(--ui-text-color); }
        #hpContainer.status-critical { background-color: rgba(245, 101, 101, 1); color: white; }
        
        /* Updated critical HP blink animation */
        #hpContainer.status-critical .ui-value {
            animation: blinkCritical 2s infinite ease-in-out;
        }

        @keyframes blinkCritical {
            50% { opacity: 0.6; }
        }

        #armorContainer {
            background-color: rgba(66, 153, 225, 0.6);
            color: white;
        }
        #resilienceContainer {
            background-color: rgba(205, 127, 50, 0.6); /* Bronze color */
            color: white;
        }

        /* Enhanced animation for disappearing elements */
        #armorContainer[data-visible="false"], #resilienceContainer[data-visible="false"] {
            opacity: 0;
            transform: translateX(-20px) scale(0.9);
            pointer-events: none;
            height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: -6px; /* Negative margin to collapse space */
            overflow: hidden;
        }
        
        /* Ultimate UI Area Fixed */
        #ultimateContainer {
            position: relative;
            min-width: 65px; 
            min-height: 28px;
            justify-content: center;
            padding: 5px 10px; /* Consistent padding */
        }
        #ultimateChargeIconContainer, #ultimateActiveLabel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
        }

        #ultimateChargeIconContainer {
            gap: 6px;
        }
        
        #ultimateChargeIconContainer.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
            pointer-events: none;
        }

        #ultimateActiveLabel {
            /* Container for the active label, no visible properties */
        }

        #ultimateChargeIconContainer .ui-icon svg {
            width: clamp(14px, 2.2vw, 16px);
            height: clamp(14px, 2.2vw, 16px);
            transition: all 0.3s ease;
        }
        .ultimate-charge-icon {
            color: var(--ultimate-charge-inactive-color);
        }
        .ultimate-charge-icon.active {
            color: var(--ultimate-charge-color);
            transform: scale(1.1);
        }

        .barOuter { 
            flex-grow: 1; 
            height: 8px; 
            background-color: rgba(0,0,0,0.15); 
            border-radius: 4px; 
            margin-left: auto; 
            min-width: 50px; 
        }
        #hpContainer .barOuter { background-color: rgba(255,255,255,0.4); } 
        #armorContainer .barOuter { background-color: rgba(255,255,255,0.4); }
        #hpBarInner, #armorBarInner { height: 100%; border-radius: 3px; transition: width 0.3s ease-out; }
        #hpContainer.status-safe #hpBarInner { background-color: white; }
        #hpContainer.status-warning #hpBarInner { background-color: #6B46C1; }
        #hpContainer.status-critical #hpBarInner { background-color: white; }
        #armorBarInner { background-color: white; }
        
        .ui-icon { 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #hpContainer .ui-icon { font-size: clamp(18px, 3vw, 20px); }
        #armorContainer .ui-icon, #resilienceContainer .ui-icon, #highScore .ui-icon, #score .ui-icon { font-size: clamp(14px, 2.2vw, 16px); }

        .ui-icon svg { width: 1em; height: 1em; fill: currentColor; }
        .ui-value { font-weight: 700; }

        /* New Power-up Text-based UI */
        #activePowerUpUI {
            display: flex;
            flex-direction: column; 
            align-items: flex-start;
            gap: 6px; 
        }
        
        .power-up-label {
            position: relative;
            padding: 4px 10px;
            font-size: clamp(11px, 1.9vw, 13px);
            font-weight: 600;
            border-radius: var(--ui-border-radius-small);
            box-shadow: var(--ui-shadow);
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: opacity 0.4s ease, transform 0.4s ease, top 0.4s ease; /* Added top transition */
            pointer-events: none;
            color: var(--ui-text-color);
            background-color: var(--ui-background-color);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            overflow: hidden; /* Hide overflow from ring */
            z-index: 1; /* Make sure text is on top */
            display: flex; /* For alignment of children */
            align-items: center;
            justify-content: center;
        }
        .power-up-label.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .power-up-label .timer-ring {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -1; /* Place ring behind text */
        }
        .power-up-label .timer-ring-fg {
            fill: none;
            stroke-width: 4; /* Thicker ring */
            stroke-linecap: butt;
            transition: stroke-dashoffset 0.1s linear;
        }

        #ultimateActiveLabel-instance {
            background: linear-gradient(135deg, rgba(126, 43, 226, 0.5), rgba(0, 123, 255, 0.5));
            color: white;
            font-weight: 700;
        }
        
        /* --- Screens & Modals --- */
        .screen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; border-radius: 28px; padding: 25px; box-sizing: border-box; opacity: 0; visibility: hidden; transition: opacity 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), visibility 0.6s cubic-bezier(0.25, 0.8, 0.25, 1); backdrop-filter: blur(5px); }
        .screen-overlay.active { opacity: 1; visibility: visible; }
        #mainMenuScreen { background-color: rgba(26, 32, 44, 0.94); z-index: 10; }
        #gameOverScreen { background-color: rgba(199, 0, 57, 0.94); z-index: 9; }
        #settingsScreen { background-color: rgba(44, 62, 80, 0.96); z-index: 11; }
        .screen-overlay h1, .screen-overlay h2 { font-size: clamp(32px, 6.8vw, 46px); font-weight: 700; margin-bottom: 20px; text-shadow: 0 3px 8px rgba(0,0,0,0.5); letter-spacing: 0.8px; }
        #settingsScreen h2 { margin-bottom: 28px; }
        .screen-overlay p { font-size: clamp(14.5px, 3.2vw, 19.5px); margin-bottom: 28px; max-width: 88%; line-height: 1.75; color: rgba(255,255,255,0.9); }
        .screen-button-container { display: flex; flex-direction: column; gap: 16px; margin-top: 12px; width: 85%; max-width: 320px; }
        .screen-button { padding: 14px 28px; font-size: clamp(15.5px, 3.6vw, 18.5px); font-weight: 600; color: white; border: none; border-radius: 12px; cursor: pointer; transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, background-color 0.2s ease-out; box-shadow: 0 5px 15px rgba(0,0,0,0.22); text-transform: uppercase; letter-spacing: 0.8px; }
        .screen-button:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 7px 20px rgba(0,0,0,0.28); }
        #startGameButton { background: linear-gradient(45deg, #4CAF50, #81C784); } #startGameButton:hover { background: linear-gradient(45deg, #388E3C, #66BB6A); }
        #settingsButton { background: linear-gradient(45deg, #607D8B, #90A4AE); } #settingsButton:hover { background: linear-gradient(45deg, #455A64, #78909C); }
        #restartButton { background: linear-gradient(45deg, #2196F3, #64B5F6); } #restartButton:hover { background: linear-gradient(45deg, #1976D2, #42A5F5); }
        #deleteHighScoreButton { background: linear-gradient(45deg, #F44336, #E57373); font-size: clamp(12.5px, 2.9vw, 15.5px); padding: 11px 22px; } #deleteHighScoreButton:hover { background: linear-gradient(45deg, #D32F2F, #EF5350); }
        #backToMenuButton { background: linear-gradient(45deg, #757575, #9E9E9E); } #backToMenuButton:hover { background: linear-gradient(45deg, #616161, #757575); }
        .settings-group { margin-bottom: 22px; width: 100%; } .settings-group label { display: block; margin-bottom: 9px; font-weight: 500; font-size: clamp(13.5px, 2.9vw, 16.5px); }
        .settings-control { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .settings-control input[type="range"] { flex-grow: 1; -webkit-appearance: none; appearance: none; width: 100%; height: 10px; background: #4A5568; border-radius: 5px; outline: none; opacity: 0.9; transition: opacity .15s ease-in-out; cursor: pointer; }
        .settings-control input[type="range"]:hover { opacity: 1; }
        .settings-control input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #E2E8F0; border-radius: 50%; cursor: pointer; border: 2px solid #2D3748; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .settings-control input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #E2E8F0; border-radius: 50%; cursor: pointer; border: 2px solid #2D3748; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .toggle-button { padding: 10px 18px; font-size: clamp(13px, 2.8vw, 15px); font-weight: 500; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out; min-width: 70px; text-align: center; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.15); }
        .toggle-button.on { background-color: #48BB78; } .toggle-button.off { background-color: #F56565; }
        .toggle-button:hover { transform: translateY(-1.5px); box-shadow: 0 3px 6px rgba(0,0,0,0.2); }
        #confirmDeleteModal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(40, 40, 50, 0.97); padding: 25px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); z-index: 100; display: none; width: 90%; max-width: 350px; color: white; }
        #confirmDeleteModal p { font-size: clamp(14px, 3vw, 17px); margin-bottom: 20px; }
        .confirm-buttons { display: flex; justify-content: space-around; gap: 10px; }
        .modal-button-delete { background: linear-gradient(45deg, #E53E3E, #FC8181) !important; } .modal-button-delete:hover { background: linear-gradient(45deg, #C53030, #F56565) !important; }
        .modal-button-cancel { background: linear-gradient(45deg, #718096, #A0AEC0) !important; } .modal-button-cancel:hover { background: linear-gradient(45deg, #4A5568, #718096) !important; }
        #leftControl, #rightControl { position: absolute; top: 0; width: 50%; height: 100%; cursor: pointer; z-index: 1; }
        #leftControl { left: 0; } #rightControl { right: 0; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- SVG Icons Definition -->
        <svg width="0" height="0" style="position:absolute;visibility:hidden;">
            <defs>
                <symbol id="icon-heart" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></symbol>
                <symbol id="icon-shield" viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></symbol>
                <symbol id="icon-bolt" viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></symbol>
                <symbol id="icon-time" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.47 10 10 10 10-4.47 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></symbol>
                <symbol id="icon-medal" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.24 2 7 4.24 7 7s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0 8c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm6 4H6c-1.1 0-2 .9-2 2v2c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-2c0-1.1-.9-2-2-2z"/></symbol>
                <symbol id="icon-resilience" viewBox="0 0 24 24"><path d="M12 2L4 5v5.11c0 5.23 3.55 9.93 8 11.89c4.45-1.96 8-6.66 8-11.89V5l-8-3zm-1 2.36l6 2.15v3.42c0 .9-.13 1.76-.38 2.58l-5.62-5.62V4.36zm2 15.28c-3.14-1.42-5-4.99-5-8.64V7.93l9 3.21v2.9c0 3.65-1.86 7.22-5 8.64h1z"/></symbol>
                
                <!-- Gradient for Ultimate Timer Ring -->
                <linearGradient id="ultimate-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#9F7AEA" />
                    <stop offset="100%" stop-color="#4299E1" />
                </linearGradient>
            </defs>
        </svg>

        <div id="mainMenuScreen" class="screen-overlay"><h1 class="text-4xl sm:text-5xl">Hindari Rintangan Pro</h1><p class="text-base sm:text-lg">Kumpulkan power-up, hindari rintangan, dan bertahanlah selama mungkin!</p><div class="screen-button-container"><button id="startGameButton" class="screen-button">Mulai Game</button><button id="settingsButton" class="screen-button">Pengaturan</button></div></div>
        <div id="settingsScreen" class="screen-overlay"><h2>Pengaturan</h2><div class="settings-group"><label for="sfxVolume">Volume Efek Suara:</label><div class="settings-control"><input type="range" id="sfxVolume" min="0" max="1" step="0.01" value="0.8"><button id="sfxToggle" class="screen-button toggle-button on">ON</button></div></div><div class="screen-button-container" style="margin-top: 30px;"><button id="deleteHighScoreButton" class="screen-button">Hapus Rekor</button><button id="backToMenuButton" class="screen-button">Kembali</button></div></div>
        <div id="confirmDeleteModal"><p>Apakah Anda yakin ingin menghapus rekor waktu tertinggi?</p><div class="confirm-buttons"><button id="confirmDeleteYes" class="screen-button modal-button-delete">Ya, Hapus</button><button id="confirmDeleteNo" class="screen-button modal-button-cancel">Batal</button></div></div>

        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-text-container">
            <div class="ui-column left">
                <div id="hpContainer" class="ui-element">
                    <span class="ui-icon"><svg><use xlink:href="#icon-heart"></use></svg></span> 
                    <span id="hpValue" class="ui-value">1000</span>
                    <div class="barOuter"><div id="hpBarInner"></div></div>
                </div>
                <div id="armorContainer" class="ui-element" data-visible="true">
                    <span class="ui-icon"><svg><use xlink:href="#icon-shield"></use></svg></span> 
                    <span id="armorValue" class="ui-value">1000</span>
                    <div class="barOuter"><div id="armorBarInner"></div></div>
                </div>
                <div id="resilienceContainer" class="ui-element" data-visible="false">
                    <span class="ui-icon"><svg><use xlink:href="#icon-resilience"></use></svg></span>
                    <span id="resilienceValue" class="ui-value">0,0%</span>
                </div>
                 <div id="activePowerUpUI"></div>
            </div>
            <div class="ui-column right">
                <div id="score" class="ui-element">
                    <span class="ui-icon"><svg><use xlink:href="#icon-time"></use></svg></span>
                    <span id="scoreValue">0,0s</span>
                </div>
                <div id="highScore" class="ui-element">
                    <span class="ui-icon"><svg><use xlink:href="#icon-medal"></use></svg></span>
                    <span id="highScoreValue">0,0s</span>
                </div>
                <!-- Ultimate UI Container Fixed -->
                <div id="ultimateContainer" class="ui-element">
                    <div id="ultimateChargeIconContainer">
                       <span class="ui-icon ultimate-charge-icon"><svg><use xlink:href="#icon-bolt"></use></svg></span>
                       <span class="ui-icon ultimate-charge-icon"><svg><use xlink:href="#icon-bolt"></use></svg></span>
                       <span class="ui-icon ultimate-charge-icon"><svg><use xlink:href="#icon-bolt"></use></svg></span>
                    </div>
                    <div id="ultimateActiveLabel"></div>
                </div>
            </div>
        </div>
        
        <div id="leftControl"></div>
        <div id="rightControl"></div>

        <div id="gameOverScreen" class="screen-overlay"><h2>Game Over!</h2><p id="finalScore">Waktu Bertahan: 0,0s</p><p id="gameOverHighScore">Rekor Waktu: 0,0s</p><div class="screen-button-container"><button id="restartButton" class="screen-button">Mulai Ulang</button></div></div>
    </div>

    <script>
        // --- SOUND INITIALIZATION ---
        let hitSynth, gameOverSynth, clickSynth, difficultyUpSynth, deleteScoreSynth;
        let absorbActivateSynth, slowActivateSynth, healActivateSynth, miniActivateSynth, polyActivateSynth, resilienceActivateSynth;
        let chargeUltimateSynth, ultimateActivateSynth, shieldActivateSynth;
        let globalReverb;
        let soundsReady = false, sfxOn = true, sfxVolume = 0.8;

        async function initSounds() {
            await Tone.start(); 
            globalReverb = new Tone.Reverb(1.5).toDestination(); globalReverb.wet.value = 0.2; 
            hitSynth = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.005, decay: 0.08, sustain: 0 } }).connect(globalReverb);
            gameOverSynth = new Tone.MonoSynth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.1, decay: 0.8, sustain: 0.1, release: 1.5 }, filterEnvelope: { attack: 0.1, decay: 0.4, sustain: 0.8, release: 1.5, baseFrequency: 180, octaves: 2.5 } }).connect(globalReverb);
            clickSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.08, sustain: 0 } }).toDestination(); 
            difficultyUpSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.15 }}).connect(globalReverb);
            deleteScoreSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0 } }).connect(globalReverb);
            absorbActivateSynth = new Tone.Synth({ oscillator: { type: "sine" }, volume: -6, envelope: { attack: 0.01, decay: 0.35, sustain: 0.05, release: 0.2 }, filter: { type: "lowpass", Q: 1.2, rolloff: -24 }, filterEnvelope: { attack: 0.005,  decay: 0.3, sustain: 0.1, release: 0.15, baseFrequency: 150, octaves: 4.5 }}).connect(globalReverb);
            slowActivateSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.1, decay: 0.8, sustain: 0.2, release: 1.0 }, detune: -10 }).connect(globalReverb);
            healActivateSynth = new Tone.FMSynth({ harmonicity: 1.5, modulationIndex: 3, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.4, sustain: 0.1, release: 0.5 }, modulation: { type: "triangle" }, modulationEnvelope: { attack: 0.02, decay: 0.2, sustain: 0, release: 0.3 }}).connect(globalReverb);
            miniActivateSynth = new Tone.PluckSynth({ attackNoise: 0.2, dampening: 7000, resonance: 0.95, release: 0.1 }).connect(globalReverb);
            polyActivateSynth = new Tone.PolySynth(Tone.Synth, { volume: -6, oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.4 }, portamento: 0.05 }).connect(globalReverb);
            resilienceActivateSynth = new Tone.MonoSynth({ oscillator: {type: 'sine'}, filter: {Q: 3}, envelope: {attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1}, filterEnvelope: {attack: 0.01, decay: 0.15, sustain: 0.05, baseFrequency: 200, octaves: 3, exponent: 2}}).connect(globalReverb);
            chargeUltimateSynth = new Tone.Synth({ oscillator: { type: "pulse", width: 0.3 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }, filter: { type: "bandpass", Q: 2, frequency: 800 }, filterEnvelope: { attack: 0.005, decay: 0.08, baseFrequency: 600, octaves: 2 }}).connect(globalReverb);
            ultimateActivateSynth = new Tone.PolySynth(Tone.Synth, { volume: -3, polyphony: 3, oscillator : { type : "fatsawtooth", count: 3, spread: 30 }, envelope: { attack: 0.1, decay: 1.5, sustain: 0.5, release: 1.0 }, filterEnvelope: { attack: 0.05, decay: 1.0, baseFrequency: 200, octaves: 5 }}).connect(globalReverb);
            shieldActivateSynth = new Tone.MetalSynth({ frequency: 150, envelope: { attack: 0.005, decay: 0.4, release: 0.1 }, harmonicity: 3.1, modulationIndex: 16, resonance: 3000, octaves: 1.5 }).connect(globalReverb);
            applyVolumeSettings(); soundsReady = true;
        }
        
        // --- DOM ELEMENT REFERENCES ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const mainMenuScreen = document.getElementById('mainMenuScreen'); const startGameButton = document.getElementById('startGameButton');
        const settingsButton = document.getElementById('settingsButton'); const settingsScreen = document.getElementById('settingsScreen'); 
        const sfxVolumeSlider = document.getElementById('sfxVolume'); const sfxToggle = document.getElementById('sfxToggle');
        const deleteHighScoreButton = document.getElementById('deleteHighScoreButton'); const backToMenuButton = document.getElementById('backToMenuButton');
        const confirmDeleteModal = document.getElementById('confirmDeleteModal'); const confirmDeleteYes = document.getElementById('confirmDeleteYes'); const confirmDeleteNo = document.getElementById('confirmDeleteNo');
        const scoreDisplay = document.getElementById('score');
        const scoreValueDisplay = document.getElementById('scoreValue'); 
        const highScoreDisplay = document.getElementById('highScore');
        const highScoreValueDisplay = document.getElementById('highScoreValue');
        const hpContainer = document.getElementById('hpContainer');
        const hpValueDisplay = document.getElementById('hpValue'); const hpBarInner = document.getElementById('hpBarInner');
        const armorContainer = document.getElementById('armorContainer'); const armorValueDisplay = document.getElementById('armorValue'); const armorBarInner = document.getElementById('armorBarInner');
        const resilienceContainer = document.getElementById('resilienceContainer'); const resilienceValueDisplay = document.getElementById('resilienceValue');
        const ultimateContainer = document.getElementById('ultimateContainer');
        const ultimateChargeIconContainer = document.getElementById('ultimateChargeIconContainer');
        const ultimateActiveLabel = document.getElementById('ultimateActiveLabel');
        const activePowerUpUIDiv = document.getElementById('activePowerUpUI');
        const gameOverScreen = document.getElementById('gameOverScreen'); const finalScoreDisplay = document.getElementById('finalScore'); const gameOverHighScoreDisplay = document.getElementById('gameOverHighScore');
        const restartButton = document.getElementById('restartButton');
        const leftControl = document.getElementById('leftControl'); const rightControl = document.getElementById('rightControl');

        // --- GAME STATE VARIABLES ---
        let player, obstacles, currentScoreTime, highScoreTime, playerHP, playerArmor, resiliencePercentage;
        let powerUpsOnScreen = [], activePowerUpEffects = {}, pendingPowerUpEffects = {};
        let animationFrameId, isGameOver = false, playerVelocityX = 0;
        let difficultyTimer, armorDecayTimer;
        let minSpawnIntervalMs, maxSpawnIntervalMs, minObstacleSpeed, maxObstacleSpeed, minPowerUpSpeed, maxPowerUpSpeed;
        let playerHitEffectTimer = 0;
        
        let nextObstacleSpawnTimer = 0;
        let lastTime = 0;

        const PLAYER_DEFAULT_COLOR = '#34495E', PLAYER_HIT_COLOR = '#E74C3C';
        const PLAYER_HIT_DURATION = 0.25; // in seconds
        let obstacleBaseRadius, powerUpObjectRadius;
        
        let ultimateChargeCount = 0;
        const ULTIMATE_CHARGE_NEEDED = 3;
        let isUltimateActive = false;
        
        // --- CONSTANTS AND DEFINITIONS ---
        const OBSTACLE_SHAPES = [ 
            { type: 'circle',   sides: 0, damage: 20,  color: '#FFEB3B' }, 
            { type: 'heptagon', sides: 7, damage: 40,  color: '#FFC107' }, 
            { type: 'hexagon',  sides: 6, damage: 70,  color: '#FF9800' }, 
            { type: 'pentagon', sides: 5, damage: 120, color: '#F4511E' }, 
            { type: 'square',   sides: 4, damage: 200, color: '#E53935' }, 
            { type: 'triangle', sides: 3, damage: 300, color: '#B71C1C' }
        ];
        
        const POWER_UP_TYPES = {
            RESILIENCE:  { id: 'RESILIENCE',  name: 'Resilience',  color: '#CD7F32', draw: drawResilienceShape,  duration: 90, minSpawn: 10,  maxSpawn: 180, onCollect: activateResilience,  onExpire: deactivateResilience,  sfxCollect: () => { if(sfxOn && soundsReady) resilienceActivateSynth.triggerAttackRelease("A2", "0.2s", Tone.now()); }},
            SLOW:        { id: 'SLOW',        name: 'Slow',        color: '#5499C7', draw: drawSlowShape,        duration: 30, minSpawn: 30,  maxSpawn: 120, onCollect: activateSlow,        onExpire: deactivateSlow,        sfxCollect: () => { if(sfxOn && soundsReady) { slowActivateSynth.triggerAttack("G2", Tone.now()); slowActivateSynth.frequency.rampTo("F#2", 0.5, Tone.now() + 0.1); slowActivateSynth.triggerRelease(Tone.now() + 0.6); }}},
            ABSORB:      { id: 'ABSORB',      name: 'Absorb',      color: '#48C9B0', draw: drawAbsorbShape,      duration: 30, minSpawn: 30,  maxSpawn: 150, onCollect: activateAbsorb,      onExpire: deactivateAbsorb,      sfxCollect: () => { if(sfxOn && soundsReady) absorbActivateSynth.triggerAttackRelease("G3", "0.35s", Tone.now(), 1.0); } },
            MINIATURIZE: { id: 'MINIATURIZE', name: 'Miniaturize', color: '#A569BD', draw: drawMiniaturizeShape, duration: 30, minSpawn: 30,  maxSpawn: 210, onCollect: activateMiniaturize, onExpire: deactivateMiniaturize, sfxCollect: () => { if(sfxOn && soundsReady) { miniActivateSynth.triggerAttackRelease("A6", "0.05s", Tone.now(), 0.7); miniActivateSynth.triggerAttackRelease("D7", "0.05s", Tone.now() + 0.04, 0.6); }}},
            POLYMORPH:   { id: 'POLYMORPH',   name: 'Polymorph',   color: '#5D6D7E', draw: drawPolymorphShape,   duration: 30, minSpawn: 30,  maxSpawn: 300, onCollect: activatePolymorph,   onExpire: deactivatePolymorph,   sfxCollect: () => { if(sfxOn && soundsReady) polyActivateSynth.triggerAttackRelease(["C4", "Eb4", "G4", "Bb4"], "0.3s", Tone.now()); }},
            SHIELD:      { id: 'SHIELD',      name: 'Shield',      color: '#4FC3F7', draw: drawShieldShapeModern,duration: 0,  minSpawn: 60,  maxSpawn: 300, onCollect: activateShield,      sfxCollect: () => { if(sfxOn && soundsReady) shieldActivateSynth.triggerAttackRelease(0.2, Tone.now()); }},
            HEAL:        { id: 'HEAL',        name: 'Heal',        color: '#2ECC71', draw: drawHealShape,        duration: 0,  minSpawn: 1,   maxSpawn: 30,  onCollect: activateHeal,        sfxCollect: () => { if(sfxOn && soundsReady) { healActivateSynth.triggerAttackRelease("C5", "0.4s", Tone.now(), 0.8); healActivateSynth.triggerAttackRelease("G5", "0.4s", Tone.now() + 0.15, 0.7); }}},
            CHARGE_ULTIMATE: { id: 'CHARGE_ULTIMATE', name: 'Ult Charge',  color: '#BF55EC', draw: drawChargeUltimateShapeModern, duration: 0, minSpawn: 15,   maxSpawn: 150, onCollect: collectUltimateCharge, sfxCollect: () => { if(sfxOn && soundsReady) chargeUltimateSynth.triggerAttackRelease("C5", "0.1s", Tone.now(), 0.6); }},
            ULTIMATE:    { id: 'ULTIMATE',    name: 'Ultimate',    color: '#007bff', draw: () => {},               duration: 30, onActivate: activateUltimateEffects, onExpire: deactivateUltimateEffects, sfxActivate: () => { if(sfxOn && soundsReady) ultimateActivateSynth.triggerAttackRelease(["C3", "G3", "C4"], "1.5s", Tone.now()); }}
        };
        
        function drawResilienceShape(ctx, x, y, radius, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x, y - radius); ctx.lineTo(x + radius, y); ctx.lineTo(x, y + radius); ctx.lineTo(x - radius, y); ctx.closePath(); ctx.fill(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = radius * 0.15; ctx.beginPath(); ctx.moveTo(x, y - radius * 0.5); ctx.lineTo(x + radius * 0.5, y); ctx.lineTo(x, y + radius * 0.5); ctx.lineTo(x - radius * 0.5, y); ctx.closePath(); ctx.stroke(); }
        function drawAbsorbShape(ctx, x, y, radius, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = radius * 0.2; ctx.beginPath(); ctx.arc(x, y, radius * 0.65, -Math.PI/2, Math.PI * 1.2); ctx.stroke(); }
        function drawSlowShape(ctx, x, y, radius, color) { ctx.strokeStyle = color; ctx.lineWidth = Math.max(1.5, radius * 0.12); for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle)); ctx.stroke(); for (let j = 0; j < 2; j++) { const subAngle = angle + (j === 0 ? Math.PI / 6 : -Math.PI / 6); const L = radius * 0.4; ctx.moveTo(x + radius * 0.6 * Math.cos(angle), y + radius * 0.6 * Math.sin(angle)); ctx.lineTo(x + radius * 0.6 * Math.cos(angle) + L * Math.cos(subAngle), y + radius * 0.6 * Math.sin(angle) + L * Math.sin(subAngle)); ctx.stroke(); }}}
        function drawHealShape(ctx, x, y, radius, color) { ctx.fillStyle = color; const barWidth = radius * 0.4; const barLength = radius * 1.4; ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 5; ctx.fillRect(x - barLength / 2, y - barWidth / 2, barLength, barWidth); ctx.fillRect(x - barWidth / 2, y - barLength / 2, barWidth, barLength); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
        function drawMiniaturizeShape(ctx, x, y, radius, color) { ctx.strokeStyle = color; ctx.lineWidth = Math.max(1.5, radius * 0.15); const L = radius * 0.8; const S = radius * 0.3; const angles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; angles.forEach(baseAngle => { const startX = x + L * Math.cos(baseAngle); const startY = y + L * Math.sin(baseAngle); const endX = x + S * Math.cos(baseAngle); const endY = y + S * Math.sin(baseAngle); ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); const arrowHeadSize = radius * 0.35; ctx.lineTo(endX + arrowHeadSize * Math.cos(baseAngle + Math.PI * 0.75), endY + arrowHeadSize * Math.sin(baseAngle + Math.PI * 0.75)); ctx.moveTo(endX, endY); ctx.lineTo(endX + arrowHeadSize * Math.cos(baseAngle - Math.PI * 0.75), endY + arrowHeadSize * Math.sin(baseAngle - Math.PI * 0.75)); ctx.stroke(); });}
        function drawPolymorphShape(ctx, x, y, radius, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(x - radius*0.35, y - radius*0.35, radius * 0.35, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(x + radius*0.3, y + radius*0.25, radius * 0.3, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2); ctx.fill(); }
        function drawChargeUltimateShapeModern(ctx, x, y, radius, colorString) { const grad = ctx.createLinearGradient(x - radius, y - radius, x + radius, y + radius); grad.addColorStop(0, '#BF55EC'); grad.addColorStop(1, '#7E57C2'); ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(x, y - radius); ctx.lineTo(x + radius * 0.8, y); ctx.lineTo(x, y + radius); ctx.lineTo(x - radius * 0.8, y); ctx.closePath(); ctx.fill(); ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.moveTo(x, y - radius * 0.5); ctx.lineTo(x + radius * 0.2, y); ctx.lineTo(x, y + radius * 0.2); ctx.lineTo(x - radius * 0.2, y); ctx.closePath(); ctx.fill(); }
        function drawShieldShapeModern(ctx, x, y, radius, color) { ctx.fillStyle = color; const w = radius * 1.7; const h = radius * 1.9; const cr = radius * 0.4; ctx.beginPath(); ctx.arc(x - w / 2 + cr, y - h / 2 + cr, cr, Math.PI, Math.PI * 1.5); ctx.lineTo(x + w / 2 - cr, y - h / 2); ctx.arc(x + w / 2 - cr, y - h / 2 + cr, cr, Math.PI * 1.5, Math.PI * 2); ctx.lineTo(x + w/2, y + h/2 - cr*1.5); ctx.quadraticCurveTo(x + w/2, y + h/2 - cr*0.5, x, y + h/2); ctx.quadraticCurveTo(x - w/2, y + h/2 - cr*0.5, x-w/2, y + h/2 - cr*1.5); ctx.lineTo(x - w / 2, y - h / 2 + cr); ctx.closePath(); ctx.fill(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = Math.max(1.5, radius * 0.12); ctx.beginPath(); ctx.moveTo(x - w * 0.25, y + h * 0.05); ctx.lineTo(x, y + h * 0.2); ctx.lineTo(x + w * 0.3, y - h * 0.1); ctx.stroke(); }
        
        // --- GAME LOGIC FUNCTIONS ---
        function activatePowerUp(typeId, effectDetails) { 
            if (isUltimateActive && typeId !== 'ULTIMATE') { 
                pendingPowerUpEffects[typeId] = { ...effectDetails }; 
            } else {
                activePowerUpEffects[typeId] = { ...effectDetails };
            }
        }
        function activateAbsorb() { activatePowerUp('ABSORB', { timeLeft: POWER_UP_TYPES.ABSORB.duration, totalDuration: POWER_UP_TYPES.ABSORB.duration }); }
        function deactivateAbsorb() { delete activePowerUpEffects.ABSORB; }
        
        function activateSlow() { activatePowerUp('SLOW', { timeLeft: POWER_UP_TYPES.SLOW.duration, totalDuration: POWER_UP_TYPES.SLOW.duration }); }
        function deactivateSlow() { delete activePowerUpEffects.SLOW; }

        function activateHeal() { playerHP = Math.min(1000, playerHP + 200); updateUIDisplay(); }
        function activateMiniaturize() { activatePowerUp('MINIATURIZE', { timeLeft: POWER_UP_TYPES.MINIATURIZE.duration, totalDuration: POWER_UP_TYPES.MINIATURIZE.duration }); }
        function deactivateMiniaturize() { delete activePowerUpEffects.MINIATURIZE; }
        function activatePolymorph() { activatePowerUp('POLYMORPH', { timeLeft: POWER_UP_TYPES.POLYMORPH.duration, totalDuration: POWER_UP_TYPES.POLYMORPH.duration }); }
        function deactivatePolymorph() { delete activePowerUpEffects.POLYMORPH; }

        function activateResilience() {
            if (activePowerUpEffects.RESILIENCE) {
                // If already active, add 10%
                resiliencePercentage = Math.min(80, resiliencePercentage + 10);
            } else {
                 // On first activation, set to 10%
                 resiliencePercentage = 10;
            }

            // Activate/refresh the timer
            activatePowerUp('RESILIENCE', {
                timeLeft: POWER_UP_TYPES.RESILIENCE.duration,
                totalDuration: POWER_UP_TYPES.RESILIENCE.duration
            });
        }
        function deactivateResilience() { 
            delete activePowerUpEffects.RESILIENCE; 
            if (!isUltimateActive) { 
                resiliencePercentage = 0; 
            } 
        }

        function collectUltimateCharge() {
            ultimateChargeCount = Math.min(ULTIMATE_CHARGE_NEEDED, ultimateChargeCount + 1);
            updateUIDisplay(); 
            if (ultimateChargeCount >= ULTIMATE_CHARGE_NEEDED) {
                triggerUltimate();
            }
        }

        function triggerUltimate() {
            if (isUltimateActive) return; 
            isUltimateActive = true; 
            ultimateChargeCount = 0; 
            if (POWER_UP_TYPES.ULTIMATE.sfxActivate) POWER_UP_TYPES.ULTIMATE.sfxActivate();
            ['ABSORB', 'SLOW', 'MINIATURIZE', 'POLYMORPH', 'RESILIENCE'].forEach(id => { if (activePowerUpEffects[id]) { pendingPowerUpEffects[id] = { ...activePowerUpEffects[id] }; delete activePowerUpEffects[id]; }});
            POWER_UP_TYPES.ULTIMATE.onActivate();
            updateUIDisplay();
        }
        
        function activateUltimateEffects() {
            activatePowerUp('ULTIMATE', { timeLeft: POWER_UP_TYPES.ULTIMATE.duration, totalDuration: POWER_UP_TYPES.ULTIMATE.duration, name: "Ultimate" });
            playerHP = 1000; playerArmor = 1000;
           
            // If resilience is active, add 10%
            if (resiliencePercentage > 0) {
                resiliencePercentage = Math.min(80, resiliencePercentage + 10);
            }

            updateUIDisplay();
        }

        function deactivateUltimateEffects() {
            isUltimateActive = false; 
            delete activePowerUpEffects.ULTIMATE;

            // If resilience wasn't pending, it gets reset.
            if (!pendingPowerUpEffects.RESILIENCE) { 
                resiliencePercentage = 0; 
            }
            // Restore any pending effects
            for (const id in pendingPowerUpEffects) { activePowerUpEffects[id] = { ...pendingPowerUpEffects[id] }; }
            pendingPowerUpEffects = {}; updateUIDisplay();
        }

        function activateShield() { playerArmor = 1000; updateUIDisplay(); }
        
        function formatTime(milliseconds) { 
            if (typeof milliseconds !== 'number' || isNaN(milliseconds)) return "0,0s"; 
            return (milliseconds / 1000).toFixed(1).replace('.', ',') + "s"; 
        }

        function loadSettings() { sfxOn = localStorage.getItem('sfxOn') === 'false' ? false : true; sfxVolume = parseFloat(localStorage.getItem('sfxVolume')); if (isNaN(sfxVolume)) sfxVolume = 0.8; sfxToggle.textContent = sfxOn ? "ON" : "OFF"; sfxToggle.classList.toggle('on', sfxOn); sfxToggle.classList.toggle('off', !sfxOn); sfxVolumeSlider.value = sfxVolume; applyVolumeSettings(); }
        function saveSettings() { localStorage.setItem('sfxOn', sfxOn); localStorage.setItem('sfxVolume', sfxVolume); }
        function applyVolumeSettings() { if (!soundsReady) return; const sfxMasterGain = sfxOn ? sfxVolume : 0; const sfxMasterVolumeDb = Tone.gainToDb(sfxMasterGain); [hitSynth, gameOverSynth, difficultyUpSynth, deleteScoreSynth, slowActivateSynth, healActivateSynth, miniActivateSynth, polyActivateSynth, resilienceActivateSynth, chargeUltimateSynth, ultimateActivateSynth, shieldActivateSynth].forEach(synth => { if (synth && typeof synth.volume !== 'undefined' && typeof synth.volume.value !== 'undefined') synth.volume.value = sfxMasterVolumeDb; }); if (absorbActivateSynth && typeof absorbActivateSynth.volume !== 'undefined' && typeof absorbActivateSynth.volume.value !== 'undefined') absorbActivateSynth.volume.value = sfxOn ? sfxMasterVolumeDb + 5 : -Infinity; if(clickSynth && typeof clickSynth.volume !== 'undefined' && typeof clickSynth.volume.value !== 'undefined') clickSynth.volume.value = sfxOn ? Tone.gainToDb(sfxVolume * 0.4) : -Infinity; }
        
        function initialScreenSetup() { 
            mainMenuScreen.classList.add('active'); 
            settingsScreen.classList.remove('active'); 
            gameCanvas.style.display = 'none'; 
            document.querySelector('.ui-text-container').style.display = 'none'; 
            gameOverScreen.classList.remove('active'); 
            leftControl.style.display = 'none'; 
            rightControl.style.display = 'none'; 
            activePowerUpUIDiv.innerHTML = ''; 
            const storedHighScore = parseInt(localStorage.getItem('obstacleGameHighScoreTime')) || 0; 
            highScoreValueDisplay.textContent = formatTime(storedHighScore); 
            loadSettings(); 
        }

        function showGameElements() { gameCanvas.style.display = 'block'; document.querySelector('.ui-text-container').style.display = 'flex'; leftControl.style.display = 'block'; rightControl.style.display = 'block'; }
        function resizeCanvas() { canvas.width = gameContainer.clientWidth; canvas.height = gameContainer.clientHeight; obstacleBaseRadius = canvas.width * 0.033; powerUpObjectRadius = obstacleBaseRadius * 1.3; if (!isGameOver && player) { const playerSize = canvas.width * 0.052; player.width = playerSize; player.height = playerSize; player.speed = canvas.width * 0.016 * 60; if (player.x + player.width > canvas.width) player.x = canvas.width - player.width; if (player.x < 0) player.x = 0; }}
        window.addEventListener('resize', resizeCanvas);
        
        function setNextObstacleSpawnTime() { 
            let effectiveMinInterval = minSpawnIntervalMs;
            let effectiveMaxInterval = maxSpawnIntervalMs;

            if (activePowerUpEffects.SLOW || isUltimateActive) {
                effectiveMinInterval *= 2;
                effectiveMaxInterval *= 2;
            }

            nextObstacleSpawnTimer = (Math.random() * (effectiveMaxInterval - effectiveMinInterval) + effectiveMinInterval) / 1000;
        }

        function initGame() {
            if (!soundsReady) { initSounds().then(loadSettings).catch(err => console.error("Gagal inisialisasi suara otomatis:", err)); } else { applyVolumeSettings(); }
            isGameOver = false; activePowerUpEffects = {}; pendingPowerUpEffects = {}; powerUpsOnScreen = [];
            isUltimateActive = false; ultimateChargeCount = 0; 
            
            mainMenuScreen.classList.remove('active'); settingsScreen.classList.remove('active'); gameOverScreen.classList.remove('active'); 
            showGameElements(); resizeCanvas(); 
            const playerSize = canvas.width * 0.052; 
            player = { x: canvas.width / 2 - playerSize / 2, y: canvas.height - playerSize - 15, width: playerSize, height: playerSize, speed: canvas.width * 0.016 * 60 };
            playerVelocityX = 0; 

            playerHP = 1000; 
            playerArmor = 1000; 
            resiliencePercentage = 0; // Starts at 0, activated by power-up

            playerHitEffectTimer = 0;
            obstacles = []; currentScoreTime = 0; 
            lastTime = performance.now();

            difficultyTimer = 0;
            armorDecayTimer = 0;

            // Updated difficulty parameters
            minSpawnIntervalMs = 25; 
            maxSpawnIntervalMs = 1000; 
            minObstacleSpeed = 100; 
            maxObstacleSpeed = 1000; 
            minPowerUpSpeed = 100;
            maxPowerUpSpeed = 500;
            
            setNextObstacleSpawnTime();
            
            Object.values(POWER_UP_TYPES).forEach(pt => { 
                if (pt.id === 'ULTIMATE') return;
                pt.nextSpawnTimer = (Math.random() * (pt.maxSpawn - pt.minSpawn) + pt.minSpawn);
            });

            highScoreTime = parseInt(localStorage.getItem('obstacleGameHighScoreTime')) || 0;
            updateUIDisplay(); 
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop(performance.now()); 
        }
        
        function drawPlayer() { ctx.fillStyle = (playerHitEffectTimer > 0) ? PLAYER_HIT_COLOR : PLAYER_DEFAULT_COLOR; ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8; let playerDrawWidth = player.width; let playerDrawHeight = player.height; if (isUltimateActive || activePowerUpEffects.MINIATURIZE) { playerDrawWidth /= 1.5; playerDrawHeight /= 1.5; } ctx.fillRect(player.x + (player.width - playerDrawWidth)/2 , player.y + (player.height - playerDrawHeight)/2, playerDrawWidth, playerDrawHeight); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
        function drawPolygon(x, y, radius, sides, color, rotation = 0) { if (sides < 3) return; ctx.beginPath(); ctx.moveTo(x + radius * Math.cos(rotation), y + radius * Math.sin(rotation)); for (let i = 1; i < sides; i++) { ctx.lineTo(x + radius * Math.cos(rotation + i * 2 * Math.PI / sides), y + radius * Math.sin(rotation + i * 2 * Math.PI / sides)); } ctx.closePath(); ctx.fillStyle = color; ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 5; ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
        function drawObstacles() { obstacles.forEach(obstacle => { let { x, y, shapeDetails, rotation } = obstacle; let currentRadius = obstacleBaseRadius; let currentShapeToDraw = shapeDetails; if (isUltimateActive || activePowerUpEffects.MINIATURIZE) currentRadius /= 1.5; if (isUltimateActive || activePowerUpEffects.POLYMORPH) currentShapeToDraw = OBSTACLE_SHAPES.find(s => s.type === 'circle'); if (currentShapeToDraw.type === 'circle') { ctx.beginPath(); ctx.arc(x, y, currentRadius, 0, Math.PI * 2); ctx.fillStyle = currentShapeToDraw.color; ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 5; ctx.fill(); ctx.closePath(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; } else { drawPolygon(x, y, currentRadius, currentShapeToDraw.sides, currentShapeToDraw.color, rotation); }});}
        function drawPowerUpsOnScreen() { powerUpsOnScreen.forEach(pu => { ctx.save(); ctx.shadowColor = 'rgba(255,255,255,0.7)'; ctx.shadowBlur = 10; POWER_UP_TYPES[pu.typeId].draw(ctx, pu.x, pu.y, powerUpObjectRadius, POWER_UP_TYPES[pu.typeId].color); ctx.restore(); });}
        
        function updatePlayer(deltaTime) { player.x += playerVelocityX * deltaTime; if (player.x < 0) player.x = 0; if (player.x + player.width > canvas.width) player.x = canvas.width - player.width; if (playerHitEffectTimer > 0) playerHitEffectTimer -= deltaTime; }
        
        function spawnObstacle() { 
            const x = Math.random() * (canvas.width - obstacleBaseRadius * 2) + obstacleBaseRadius; 
            const y = -obstacleBaseRadius; 
            let shapeDetails = OBSTACLE_SHAPES[Math.floor(Math.random() * OBSTACLE_SHAPES.length)]; 

            let effectiveMinSpeed = minObstacleSpeed;
            let effectiveMaxSpeed = maxObstacleSpeed;

            if (activePowerUpEffects.SLOW || isUltimateActive) {
                effectiveMinSpeed *= 0.5;
                effectiveMaxSpeed *= 0.5;
            }

            let speed = Math.random() * (effectiveMaxSpeed - effectiveMinSpeed) + effectiveMinSpeed; 
            obstacles.push({ x, y, speed, shapeDetails: shapeDetails, damage: shapeDetails.damage, rotation: Math.random() * Math.PI * 2 }); 
        }

        function updateObstacles(deltaTime) { obstacles.forEach((obstacle, index) => { obstacle.y += obstacle.speed * deltaTime; let currentRadius = obstacleBaseRadius * ((isUltimateActive || activePowerUpEffects.MINIATURIZE) ? (1/1.5) : 1); if (obstacle.y - currentRadius > canvas.height) obstacles.splice(index, 1); });}
        
        function spawnPowerUp(typeId) { 
            const x = Math.random() * (canvas.width - powerUpObjectRadius * 2) + powerUpObjectRadius; 
            const y = -powerUpObjectRadius; 
            const speed = Math.random() * (maxPowerUpSpeed - minPowerUpSpeed) + minPowerUpSpeed;
            powerUpsOnScreen.push({ x, y, radius: powerUpObjectRadius, typeId, speed }); 
        }

        function updatePowerUpsOnScreen(deltaTime) { 
            powerUpsOnScreen.forEach((pu, index) => { 
                pu.y += pu.speed * deltaTime; 
                if (pu.y - pu.radius > canvas.height) {
                    powerUpsOnScreen.splice(index, 1); 
                }
            });
        }
        
        function managePowerUpSpawning(deltaTime) {
            Object.values(POWER_UP_TYPES).forEach(pt => {
                if (pt.id === 'ULTIMATE') return;
                
                if (!pt.nextSpawnTimer) {
                    pt.nextSpawnTimer = (Math.random() * (pt.maxSpawn - pt.minSpawn) + pt.minSpawn);
                }

                pt.nextSpawnTimer -= deltaTime;
                if (pt.nextSpawnTimer <= 0) {
                    spawnPowerUp(pt.id);
                    pt.nextSpawnTimer = (Math.random() * (pt.maxSpawn - pt.minSpawn) + pt.minSpawn);
                }
            });
        }

        function updateActivePowerUpEffects(deltaTime) {
            const effectKeys = Object.keys(activePowerUpEffects);
            effectKeys.forEach(typeId => {
                if (activePowerUpEffects[typeId]) {
                    if (activePowerUpEffects[typeId].timeLeft > 0) {
                        activePowerUpEffects[typeId].timeLeft -= deltaTime;
                    } else {
                        const powerUpDef = POWER_UP_TYPES[typeId];
                        if (powerUpDef && powerUpDef.onExpire) {
                            powerUpDef.onExpire();
                        } else {
                            delete activePowerUpEffects[typeId];
                        }
                    }
                }
            });
            updateActivePowerUpUIDisplay();
        }

        function updateActivePowerUpUIDisplay() {
            const currentActiveIds = Object.keys(activePowerUpEffects).filter(id => id !== 'ULTIMATE' && activePowerUpEffects[id].totalDuration > 0);
            
            const uiElements = activePowerUpUIDiv.querySelectorAll('.power-up-label');
            uiElements.forEach(el => {
                const typeId = el.dataset.typeid;
                if (!currentActiveIds.includes(typeId)) {
                    el.classList.remove('visible');
                    setTimeout(() => el.remove(), 400); 
                }
            });

            currentActiveIds.forEach(typeId => {
                let labelDiv = activePowerUpUIDiv.querySelector(`.power-up-label[data-typeid="${typeId}"]`);
                const effect = activePowerUpEffects[typeId];
                const puInfo = POWER_UP_TYPES[typeId];
                if (!puInfo) return;

                if (!labelDiv) {
                    labelDiv = document.createElement('div');
                    labelDiv.className = 'power-up-label';
                    labelDiv.dataset.typeid = typeId;
                    
                    const ringHTML = `<svg class="timer-ring"><path class="timer-ring-fg" d="" style="stroke: ${puInfo.color};"/></svg><span>${puInfo.name}</span>`;
                    labelDiv.innerHTML = ringHTML;
                    activePowerUpUIDiv.appendChild(labelDiv);
                    
                    requestAnimationFrame(() => {
                        if (!document.body.contains(labelDiv)) return;
                        const w = labelDiv.offsetWidth;
                        const h = labelDiv.offsetHeight;
                        const r = parseFloat(getComputedStyle(labelDiv).borderRadius) || 0;
                        const sw = 4; // stroke-width
                        const ring = labelDiv.querySelector('.timer-ring');
                        ring.setAttribute('viewBox', `0 0 ${w} ${h}`); 
                        const path = `M ${r},${sw/2} L ${w-r},${sw/2} A ${r-sw/2},${r-sw/2} 0 0 1 ${w-sw/2},${r} L ${w-sw/2},${h-r} A ${r-sw/2},${r-sw/2} 0 0 1 ${w-r},${h-sw/2} L ${r},${h-sw/2} A ${r-sw/2},${r-sw/2} 0 0 1 ${sw/2},${h-r} L ${sw/2},${r} A ${r-sw/2},${r-sw/2} 0 0 1 ${r},${sw/2}`;
                        
                        const ringFg = labelDiv.querySelector('.timer-ring-fg');
                        ringFg.setAttribute('d', path);
                        const pathLength = ringFg.getTotalLength();
                        if (pathLength > 0) {
                            ringFg.dataset.pathLength = pathLength;
                        }
                        labelDiv.classList.add('visible');
                    });
                }
                
                const percentage = (effect.timeLeft / effect.totalDuration);
                const ringFg = labelDiv.querySelector('.timer-ring-fg');
                const pathLength = parseFloat(ringFg.dataset.pathLength);

                if(pathLength > 0){
                    ringFg.style.strokeDasharray = `${pathLength} ${pathLength}`;
                    ringFg.style.strokeDashoffset = pathLength * (1 - percentage);
                }
            });
        }
        
        function updateArmor(deltaTime) { 
            armorDecayTimer += deltaTime;
            if (armorDecayTimer >= 1) {
                if (playerArmor > 0 && !isUltimateActive) {
                    playerArmor = Math.max(0, playerArmor - 20);
                }
                armorDecayTimer -= 1; 
            }
        }

        function checkCollisions() { const isMini = isUltimateActive || activePowerUpEffects.MINIATURIZE; const isPoly = isUltimateActive || activePowerUpEffects.POLYMORPH; let playerDrawWidth = player.width * (isMini ? (1/1.5) : 1); let playerDrawHeight = player.height * (isMini ? (1/1.5) : 1); let playerCenterX = player.x + player.width / 2; let playerCenterY = player.y + player.height / 2; obstacles.forEach((obstacle, index) => { let currentObsRadius = obstacleBaseRadius * (isMini ? (1/1.5) : 1); let damageToDeal = obstacle.damage; if (isPoly) { const circleShapeData = OBSTACLE_SHAPES.find(s => s.type === 'circle'); if (circleShapeData) damageToDeal = circleShapeData.damage; } const distX = Math.abs(obstacle.x - playerCenterX); const distY = Math.abs(obstacle.y - playerCenterY); if (distX > (playerDrawWidth / 2 + currentObsRadius)) return; if (distY > (playerDrawHeight / 2 + currentObsRadius)) return; if (distX <= (playerDrawWidth / 2)) { obstacles.splice(index, 1); handleCollision(damageToDeal); return; }  if (distY <= (playerDrawHeight / 2)) { obstacles.splice(index, 1); handleCollision(damageToDeal); return; } const dxCorner = distX - playerDrawWidth / 2; const dyCorner = distY - playerDrawHeight / 2; if (dxCorner * dxCorner + dyCorner * dyCorner <= (currentObsRadius * currentObsRadius)) { obstacles.splice(index, 1); handleCollision(damageToDeal); return; } }); powerUpsOnScreen.forEach((pu, index) => { const dx = playerCenterX - pu.x; const dy = playerCenterY - pu.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < playerDrawWidth / 2 + pu.radius) { if (POWER_UP_TYPES[pu.typeId].sfxCollect && soundsReady) POWER_UP_TYPES[pu.typeId].sfxCollect(); POWER_UP_TYPES[pu.typeId].onCollect(); powerUpsOnScreen.splice(index, 1); }}); }
        
        function handleCollision(rawDamageAmount) {
            let currentDamage = rawDamageAmount;

            // Step 1: Apply damage reduction from current resilience.
            if (resiliencePercentage > 0) {
                currentDamage *= (1 - (resiliencePercentage / 100));
            }

            // Step 2: Apply other reductions (Absorb).
            if (isUltimateActive || activePowerUpEffects.ABSORB) {
                currentDamage /= 2;
            }

            // Step 3: Distribute final damage to armor and HP.
            let damageToArmor = 0;
            let damageToHp = 0;
            if (playerArmor > 0) {
                damageToArmor = Math.ceil(currentDamage / 2);
                damageToHp = Math.floor(currentDamage / 2);
                if (playerArmor >= damageToArmor) {
                    playerArmor -= damageToArmor;
                } else {
                    const remainingAfterArmor = damageToArmor - playerArmor;
                    playerArmor = 0;
                    damageToHp += remainingAfterArmor;
                }
            } else {
                damageToHp = currentDamage;
            }

            playerHP -= damageToHp;
            
            // Step 4: After damage is dealt, convert raw damage to resilience if effect is active.
            if (activePowerUpEffects.RESILIENCE) {
                const resilienceToAdd = rawDamageAmount / 100;
                resiliencePercentage = Math.min(80, resiliencePercentage + resilienceToAdd);
            }

            // Final updates
            playerHP = Math.max(0, playerHP);
            playerHitEffectTimer = PLAYER_HIT_DURATION;
            if (sfxOn && soundsReady) hitSynth.triggerAttackRelease(0.08, Tone.now());
            if (playerHP <= 0) gameOver();
            updateUIDisplay();
        }

        function gameOver() { isGameOver = true; cancelAnimationFrame(animationFrameId); playerVelocityX = 0; if (sfxOn && soundsReady) gameOverSynth.triggerAttackRelease("G2", "1.2n", Tone.now()); if (isUltimateActive && POWER_UP_TYPES.ULTIMATE.onExpire) POWER_UP_TYPES.ULTIMATE.onExpire(); const activeEffectKeys = Object.keys(activePowerUpEffects); activeEffectKeys.forEach(typeId => { const powerUpDef = POWER_UP_TYPES[typeId]; if (powerUpDef && powerUpDef.onExpire && typeId !== 'ULTIMATE') powerUpDef.onExpire(); }); activePowerUpEffects = {}; pendingPowerUpEffects = {}; isUltimateActive = false; resiliencePercentage = 0; if (currentScoreTime > highScoreTime) { highScoreTime = currentScoreTime; localStorage.setItem('obstacleGameHighScoreTime', highScoreTime.toString()); } finalScoreDisplay.textContent = `Waktu Bertahan: ${formatTime(currentScoreTime)}`; gameOverHighScoreDisplay.textContent = `Rekor Waktu: ${formatTime(highScoreTime)}`; gameOverScreen.classList.add('active'); leftControl.style.display = 'none'; rightControl.style.display = 'none'; activePowerUpUIDiv.innerHTML = ''; }
        
        function updateUIDisplay() {
            scoreValueDisplay.textContent = formatTime(currentScoreTime);
            highScoreValueDisplay.textContent = formatTime(highScoreTime);
            
            hpValueDisplay.textContent = Math.round(playerHP);
            hpBarInner.style.width = `${Math.max(0, (playerHP / 1000) * 100)}%`;
            hpContainer.classList.toggle('status-safe', playerHP > 500);
            hpContainer.classList.toggle('status-warning', playerHP <= 500 && playerHP > 200);
            hpContainer.classList.toggle('status-critical', playerHP <= 200);
            
            armorValueDisplay.textContent = Math.round(playerArmor);
            armorBarInner.style.width = `${Math.max(0, (playerArmor / 1000) * 100)}%`;
            armorContainer.dataset.visible = playerArmor > 0;

            resilienceValueDisplay.textContent = `${resiliencePercentage.toFixed(1).replace('.', ',')}%`;
            resilienceContainer.dataset.visible = resiliencePercentage > 0;
            
            // --- NEW: Handle Ultimate UI visibility and animation ---
            if (isUltimateActive) {
                ultimateChargeIconContainer.classList.add('hidden');
                
                let labelDiv = ultimateActiveLabel.querySelector('.power-up-label');
                if (!labelDiv) {
                    labelDiv = document.createElement('div');
                    labelDiv.className = 'power-up-label';
                    labelDiv.id = 'ultimateActiveLabel-instance'; // for specific css styling
                    ultimateActiveLabel.appendChild(labelDiv);
                    setTimeout(() => labelDiv.classList.add('visible'), 10);
                }

                const effect = activePowerUpEffects.ULTIMATE;
                if(effect) {
                    const percentage = (effect.timeLeft / effect.totalDuration);
                    labelDiv.innerHTML = `<svg class="timer-ring"><path class="timer-ring-fg" d="" style="stroke: url(#ultimate-gradient);"/></svg><span>Ultimate</span>`;
                    
                    requestAnimationFrame(() => {
                         if (!document.body.contains(labelDiv)) return; // Don't run if element is gone
                         const w = labelDiv.offsetWidth;
                         const h = labelDiv.offsetHeight;
                         const r = parseFloat(getComputedStyle(labelDiv).borderRadius) || 0;
                         const sw = 4;
                         const ring = labelDiv.querySelector('.timer-ring');
                         ring.setAttribute('viewBox', `0 0 ${w} ${h}`);
                         const path = `M ${r},${sw/2} L ${w-r},${sw/2} A ${r-sw/2},${r-sw/2} 0 0 1 ${w-sw/2},${r} L ${w-sw/2},${h-r} A ${r-sw/2},${r-sw/2} 0 0 1 ${w-r},${h-sw/2} L ${r},${h-sw/2} A ${r-sw/2},${r-sw/2} 0 0 1 ${sw/2},${h-r} L ${sw/2},${r} A ${r-sw/2},${r-sw/2} 0 0 1 ${r},${sw/2}`;
                         const ringFg = labelDiv.querySelector('.timer-ring-fg');
                         ringFg.setAttribute('d', path);
                         const pathLength = ringFg.getTotalLength();

                         if(pathLength > 0){
                            ringFg.style.strokeDasharray = `${pathLength} ${pathLength}`;
                            ringFg.style.strokeDashoffset = pathLength * (1 - percentage);
                         }
                    });
                }
            } else {
                ultimateChargeIconContainer.classList.remove('hidden');
                
                let labelDiv = ultimateActiveLabel.querySelector('.power-up-label');
                if (labelDiv) {
                    labelDiv.classList.remove('visible');
                    setTimeout(() => { if(labelDiv) labelDiv.remove() }, 400); // Remove after transition
                }

                const icons = ultimateChargeIconContainer.querySelectorAll('.ultimate-charge-icon');
                icons.forEach((icon, index) => {
                    icon.classList.toggle('active', index < ultimateChargeCount);
                });
            }
        }

        function updateDifficulty(deltaTime) { 
            difficultyTimer += deltaTime;
            if (difficultyTimer >= 10) {
                 minSpawnIntervalMs = Math.max(25, minSpawnIntervalMs / 1.05);
                 maxSpawnIntervalMs = Math.max(100, maxSpawnIntervalMs / 1.05); 
                 if (minSpawnIntervalMs >= maxSpawnIntervalMs) maxSpawnIntervalMs = minSpawnIntervalMs + 75; 
                 // Peningkatan kecepatan dihapus sesuai permintaan
                 difficultyTimer -= 10;
            }
        }

        function gameLoop(currentTime) { 
            if (isGameOver) return;
            animationFrameId = requestAnimationFrame(gameLoop);

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            currentScoreTime += deltaTime * 1000;

            updateDifficulty(deltaTime); 
            updateArmor(deltaTime); 
            updateActivePowerUpEffects(deltaTime); 
            managePowerUpSpawning(deltaTime); 
            
            nextObstacleSpawnTimer -= deltaTime;
            if (nextObstacleSpawnTimer <= 0) { 
                spawnObstacle(); 
                setNextObstacleSpawnTime(); 
            } 
            
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            updatePlayer(deltaTime); 
            updateObstacles(deltaTime); 
            updatePowerUpsOnScreen(deltaTime); 
            drawObstacles(); 
            drawPowerUpsOnScreen(); 
            drawPlayer(); 
            checkCollisions(); 
            updateUIDisplay(); 
        }

        function moveLeft() { if (!isGameOver) playerVelocityX = -player.speed; }
        function moveRight() { if (!isGameOver) playerVelocityX = player.speed; }
        function stopMovement() { playerVelocityX = 0; }
        
        // --- EVENT LISTENERS ---
        settingsButton.addEventListener('click', () => { if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.7); mainMenuScreen.classList.remove('active'); settingsScreen.classList.add('active'); });
        backToMenuButton.addEventListener('click', () => { if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.7); settingsScreen.classList.remove('active'); mainMenuScreen.classList.add('active'); saveSettings(); });
        sfxToggle.addEventListener('click', () => { sfxOn = !sfxOn; sfxToggle.textContent = sfxOn ? "ON" : "OFF"; sfxToggle.classList.toggle('on', sfxOn); sfxToggle.classList.toggle('off', !sfxOn); applyVolumeSettings(); if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("D4", "16n", Tone.now(), 0.6); });
        sfxVolumeSlider.addEventListener('input', (e) => { sfxVolume = parseFloat(e.target.value); applyVolumeSettings(); });
        sfxVolumeSlider.addEventListener('change', saveSettings); 
        deleteHighScoreButton.addEventListener('click', () => { if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("A3", "8n", Tone.now(), 0.7); confirmDeleteModal.style.display = 'flex'; });
        confirmDeleteYes.addEventListener('click', () => { if (sfxOn && soundsReady) deleteScoreSynth.triggerAttackRelease(0.1, Tone.now()); localStorage.removeItem('obstacleGameHighScoreTime'); highScoreTime = 0; updateUIDisplay(); highScoreValueDisplay.textContent = formatTime(highScoreTime); if (gameOverScreen.classList.contains('active')) gameOverHighScoreDisplay.textContent = formatTime(highScoreTime); confirmDeleteModal.style.display = 'none'; });
        confirmDeleteNo.addEventListener('click', () => { if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C3", "16n", Tone.now(), 0.5); confirmDeleteModal.style.display = 'none'; });
        
        startGameButton.addEventListener('click', () => {
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.8);
            if (!soundsReady) { 
                initSounds().then(() => { 
                    loadSettings(); 
                    if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.8); 
                    initGame(); 
                }).catch(err => { 
                    console.error("Gagal inisialisasi suara saat klik:", err); 
                    initGame(); 
                }); 
                return; 
            }
            initGame(); 
        }); 
        restartButton.addEventListener('click', () => { 
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.8); 
            initGame(); 
        }); 
        
        leftControl.addEventListener('mousedown', moveLeft); leftControl.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft(); }, { passive: false }); 
        rightControl.addEventListener('mousedown', moveRight); rightControl.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight(); }, { passive: false });
        document.addEventListener('mouseup', stopMovement); document.addEventListener('touchend', stopMovement); document.addEventListener('touchcancel', stopMovement); 
        
        // --- INITIALIZE ---
        initialScreenSetup();
    </script>
</body>
</html>
