<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hindari Rintangan Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #6DD5FA 0%, #FF758C 100%); 
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            font-family: 'Poppins', sans-serif; 
            padding-top: 2vh; 
        }
        #gameContainer {
            position: relative;
            width: 90vw; 
            max-width: 650px; 
            aspect-ratio: 9 / 18; 
            background-color: rgba(255, 255, 255, 0.95); 
            border-radius: 24px; 
            box-shadow: 0 20px 45px rgba(0,0,0,0.25); 
            overflow: hidden; 
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 24px; 
        }
        .ui-text-container { 
            position: absolute;
            top: 20px; 
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; 
        }
        .ui-column {
            display: flex;
            flex-direction: column;
            gap: 10px; 
        }
        .ui-column.right {
            align-items: flex-end;
        }
        .ui-element {
            color: #1A202C; 
            font-weight: 600;
            padding: 6px 10px; 
            border-radius: 8px; 
            background-color: rgba(255, 255, 255, 0.8); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.07);
            text-align: center;
        }
        #hpContainer.ui-element, #score.ui-element {
            font-size: clamp(11px, 2.2vw, 14px); 
            min-width: 80px;
        }
        #highScore.ui-element {
            font-size: clamp(10px, 1.9vw, 12.5px);
            min-width: 70px;
            padding: 5px 8px;
        }
        
        #hpContainer {
            display: flex;
            align-items: center;
            gap: 7px;
        }
        #hpBarOuter {
            width: 100px; 
            height: 14px; 
            background-color: rgba(0,0,0,0.1);
            border-radius: 7px;
            padding: 2px;
            box-shadow: inset 0 1px 2.5px rgba(0,0,0,0.1);
        }
        #hpBarInner {
            height: 100%;
            background-color: #4CAF50; 
            border-radius: 5px;
            transition: width 0.3s ease-out, background-color 0.3s ease-out;
        }
        
        #activePowerUpUI {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px; 
            margin-top: 4px; 
        }
        .active-powerup-info {
            display: flex;
            align-items: center;
            gap: 6px; 
            font-size: clamp(10px, 1.9vw, 12.5px); 
            color: white;
            background-color: rgba(0,0,0,0.7); 
            padding: 4px 7px; 
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .powerup-timer-bar-container {
            width: 60px; 
            height: 6px; 
            background-color: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        .powerup-timer-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .screen-overlay { 
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; text-align: center;
            border-radius: 24px; padding: 25px; 
            box-sizing: border-box; opacity: 0; 
            visibility: hidden; 
            transition: opacity 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), visibility 0.6s cubic-bezier(0.25, 0.8, 0.25, 1); 
            backdrop-filter: blur(5px); 
        }
        .screen-overlay.active { opacity: 1; visibility: visible; }
        #mainMenuScreen { background-color: rgba(26, 32, 44, 0.92); z-index: 10; }
        #gameOverScreen { background-color: rgba(199, 0, 57, 0.92); z-index: 9; }
        #settingsScreen { background-color: rgba(44, 62, 80, 0.95); z-index: 11; }
        
        .screen-overlay h1, .screen-overlay h2 {
            font-size: clamp(30px, 6.5vw, 44px); 
            font-weight: 700; margin-bottom: 18px;
            text-shadow: 0 3px 7px rgba(0,0,0,0.45);
            letter-spacing: 0.5px; 
        }
         #settingsScreen h2 { margin-bottom: 25px; }

        .screen-overlay p {
            font-size: clamp(14px, 3.1vw, 19px); 
            margin-bottom: 25px; max-width: 85%;
            line-height: 1.7;
            color: rgba(255,255,255,0.85); 
        }
        .screen-button-container { 
            display: flex;
            flex-direction: column;
            gap: 15px; 
            margin-top: 10px;
            width: 80%;
            max-width: 300px; 
        }
        .screen-button { 
            padding: 13px 25px; font-size: clamp(15px, 3.5vw, 18px);
            font-weight: 600; color: white;
            border: none; border-radius: 10px; 
            cursor: pointer;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, background-color 0.2s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            text-transform: uppercase; 
            letter-spacing: 0.5px;
        }
        .screen-button:hover {
            transform: translateY(-2.5px) scale(1.01); 
            box-shadow: 0 6px 16px rgba(0,0,0,0.25);
        }
        #startGameButton { background: linear-gradient(45deg, #4CAF50, #81C784); }
        #startGameButton:hover { background: linear-gradient(45deg, #388E3C, #66BB6A); }
        #settingsButton { background: linear-gradient(45deg, #607D8B, #90A4AE); } 
        #settingsButton:hover { background: linear-gradient(45deg, #455A64, #78909C); }
        #restartButton { background: linear-gradient(45deg, #2196F3, #64B5F6); }
        #restartButton:hover { background: linear-gradient(45deg, #1976D2, #42A5F5); }
        #deleteHighScoreButton { background: linear-gradient(45deg, #F44336, #E57373); font-size: clamp(12px, 2.8vw, 15px); padding: 10px 20px; }
        #deleteHighScoreButton:hover { background: linear-gradient(45deg, #D32F2F, #EF5350); }
        #backToMenuButton { background: linear-gradient(45deg, #757575, #9E9E9E); } 
        #backToMenuButton:hover { background: linear-gradient(45deg, #616161, #757575); }

        .settings-group { margin-bottom: 20px; width: 100%; }
        .settings-group label { display: block; margin-bottom: 8px; font-weight: 500; font-size: clamp(13px, 2.8vw, 16px); }
        .settings-control { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        .settings-control input[type="range"] { flex-grow: 1; cursor: pointer; -webkit-appearance: none; appearance: none; height: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; outline: none;}
        .settings-control input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .settings-control input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: #fff; border-radius: 50%; cursor: pointer; border:none; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .toggle-button { padding: 8px 15px; font-size: clamp(12px, 2.5vw, 14px); }
        .toggle-button.on { background-color: #4CAF50; }
        .toggle-button.off { background-color: #f44336; }

        #confirmDeleteModal {
            position: fixed; 
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(40, 40, 50, 0.97); 
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            z-index: 100; 
            display: none; 
            width: 90%;
            max-width: 350px;
            color: white;
        }
        #confirmDeleteModal p { font-size: clamp(14px, 3vw, 17px); margin-bottom: 20px; }
        .confirm-buttons { display: flex; justify-content: space-around; gap: 10px; }

        #leftControl, #rightControl {
            position: absolute; top: 0; width: 50%; height: 100%;
            cursor: pointer;  z-index: 1; 
        }
        #leftControl { left: 0; }
        #rightControl { right: 0; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="mainMenuScreen" class="screen-overlay">
            <h1>Hindari Rintangan Pro</h1>
            <p>Kumpulkan power-up, hindari rintangan, dan bertahanlah selama mungkin!</p>
            <div class="screen-button-container">
                <button id="startGameButton" class="screen-button">Mulai Game</button>
                <button id="settingsButton" class="screen-button">Pengaturan</button>
            </div>
        </div>

        <div id="settingsScreen" class="screen-overlay">
            <h2>Pengaturan</h2>
            <div class="settings-group">
                <label for="sfxVolume">Volume Efek Suara:</label>
                <div class="settings-control">
                    <input type="range" id="sfxVolume" min="0" max="1" step="0.01" value="0.8">
                    <button id="sfxToggle" class="screen-button toggle-button on">ON</button>
                </div>
            </div>
            <div class="screen-button-container" style="margin-top: 30px;">
                <button id="deleteHighScoreButton" class="screen-button">Hapus Rekor</button>
                <button id="backToMenuButton" class="screen-button">Kembali</button>
            </div>
        </div>

        <div id="confirmDeleteModal">
            <p>Apakah Anda yakin ingin menghapus rekor waktu tertinggi?</p>
            <div class="confirm-buttons">
                <button id="confirmDeleteYes" class="screen-button" style="background-color: #D32F2F;">Ya, Hapus</button>
                <button id="confirmDeleteNo" class="screen-button" style="background-color: #757575;">Batal</button>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-text-container">
            <div class="ui-column left">
                <div id="hpContainer" class="ui-element">
                    <span>HP:</span>
                    <div id="hpBarOuter"><div id="hpBarInner"></div></div>
                </div>
                <div id="activePowerUpUI"></div> 
            </div>
            <div class="ui-column right">
                <div id="score" class="ui-element">Waktu: 0,00s</div>
                <div id="highScore" class="ui-element">Rekor: 0,00s</div>
            </div>
        </div>
        
        <div id="leftControl"></div>
        <div id="rightControl"></div>

        <div id="gameOverScreen" class="screen-overlay">
            <h2>Game Over!</h2>
            <p id="finalScore">Waktu Bertahan: 0,00s</p>
            <p id="gameOverHighScore">Rekor Waktu: 0,00s</p>
            <div class="screen-button-container">
                <button id="restartButton" class="screen-button">Mulai Ulang</button>
            </div>
        </div>
    </div>

    <script>
        // --- Tone.js Sound Synthesizers ---
        let hitSynth, gameOverSynth, clickSynth, difficultyUpSynth, deleteScoreSynth;
        let absorbActivateSynth, slowActivateSynth, healActivateSynth, miniActivateSynth, polyActivateSynth;
        let globalReverb;

        let soundsReady = false;
        let sfxOn = true; 
        let sfxVolume = 0.8; 

        async function initSounds() {
            await Tone.start(); 
            
            globalReverb = new Tone.Reverb(1.5).toDestination();
            globalReverb.wet.value = 0.2; 

            hitSynth = new Tone.NoiseSynth({ 
                noise: { type: 'pink' }, 
                envelope: { attack: 0.005, decay: 0.08, sustain: 0 } 
            }).connect(globalReverb);

            gameOverSynth = new Tone.MonoSynth({ 
                oscillator: { type: "sawtooth" }, 
                envelope: { attack: 0.1, decay: 0.8, sustain: 0.1, release: 1.5 }, 
                filterEnvelope: { attack: 0.1, decay: 0.4, sustain: 0.8, release: 1.5, baseFrequency: 180, octaves: 2.5 } 
            }).connect(globalReverb);

            clickSynth = new Tone.MembraneSynth({ 
                pitchDecay: 0.01, octaves: 2, 
                envelope: { attack: 0.001, decay: 0.08, sustain: 0 } 
            }).toDestination(); 

            difficultyUpSynth = new Tone.Synth({ 
                oscillator: { type: 'sine' }, 
                envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.15 }
            }).connect(globalReverb);
            
            deleteScoreSynth = new Tone.NoiseSynth({ 
                noise: { type: "white" }, 
                envelope: { attack: 0.01, decay: 0.1, sustain: 0 } 
            }).connect(globalReverb);

            // --- Power-up SFX Definitions ---
            // PERBAIKAN SFX ABSORB:
            absorbActivateSynth = new Tone.Synth({
                oscillator: { type: "sine" }, // Gelombang sine lembut
                volume: -6, // Sedikit lebih pelan secara inheren
                envelope: { // Amplop utama
                    attack: 0.01,
                    decay: 0.35, // Durasi suara keseluruhan
                    sustain: 0.05,
                    release: 0.2
                },
                filter: { // Jenis filter
                    type: "lowpass",
                    Q: 1.2, // Sedikit resonansi untuk membantu sweep terdengar
                    rolloff: -24 // Cutoff yang lebih curam
                },
                filterEnvelope: { // Mengontrol frekuensi cutoff filter dari waktu ke waktu
                    attack: 0.005,  // Attack filter sangat cepat untuk membukanya
                    decay: 0.3,    // Filter menyapu dari terbuka ke 'baseFrequency + sustain_offset'
                    sustain: 0.1,   // Level sustain untuk filter (relatif terhadap puncak).
                    release: 0.15,   // Release filter
                    baseFrequency: 150, // Frekuensi terendah yang akan dicapai filter (hampir tertutup)
                    octaves: 4.5      // Berapa oktaf *di atas* baseFrequency filter akan menyapu
                                    // Pada puncak attack, cutoff = baseFrequency * (2^octaves)
                                    // Kemudian meluruh menuju baseFrequency
                }
            }).connect(globalReverb);


            slowActivateSynth = new Tone.Synth({ 
                oscillator: { type: "triangle" },
                envelope: { attack: 0.1, decay: 0.8, sustain: 0.2, release: 1.0 }, 
                detune: -10 
            }).connect(globalReverb);

            healActivateSynth = new Tone.FMSynth({ 
                harmonicity: 1.5,
                modulationIndex: 3,
                oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.4, sustain: 0.1, release: 0.5 },
                modulation: { type: "triangle" },
                modulationEnvelope: { attack: 0.02, decay: 0.2, sustain: 0, release: 0.3 }
            }).connect(globalReverb);

            miniActivateSynth = new Tone.PluckSynth({ 
                attackNoise: 0.2,
                dampening: 7000, 
                resonance: 0.95,
                release: 0.1 
            }).connect(globalReverb);
            
            polyActivateSynth = new Tone.PolySynth(Tone.Synth, { 
                volume: -6, 
                oscillator: { type: "triangle" },
                envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.4 },
                portamento: 0.05 
            }).connect(globalReverb);
            
            applyVolumeSettings(); 
            soundsReady = true;
            console.log("Sound system initialized.");
        }
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        const mainMenuScreen = document.getElementById('mainMenuScreen');
        const startGameButton = document.getElementById('startGameButton');
        const settingsButton = document.getElementById('settingsButton'); 
        const settingsScreen = document.getElementById('settingsScreen'); 
        const sfxVolumeSlider = document.getElementById('sfxVolume');
        const sfxToggle = document.getElementById('sfxToggle');
        const deleteHighScoreButton = document.getElementById('deleteHighScoreButton'); 
        const backToMenuButton = document.getElementById('backToMenuButton');
        const confirmDeleteModal = document.getElementById('confirmDeleteModal');
        const confirmDeleteYes = document.getElementById('confirmDeleteYes');
        const confirmDeleteNo = document.getElementById('confirmDeleteNo');

        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const hpDisplayContainer = document.getElementById('hpContainer');
        const hpBarInner = document.getElementById('hpBarInner');
        const activePowerUpUIDiv = document.getElementById('activePowerUpUI');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const gameOverHighScoreDisplay = document.getElementById('gameOverHighScore');
        const restartButton = document.getElementById('restartButton');
        const leftControl = document.getElementById('leftControl');
        const rightControl = document.getElementById('rightControl');

        let player, obstacles, currentScoreTime, highScoreTime, playerHP;
        let powerUpsOnScreen = []; 
        let activePowerUpEffects = {}; 
        let animationFrameId;
        let isGameOver = false;
        let playerVelocityX = 0; 
        let gameStartTime, lastMultiplierUpdateTime;
        let minSpawnIntervalMs, maxSpawnIntervalMs;
        let minObstacleSpeed, maxObstacleSpeed; 
        let nextObstacleSpawnFrame;
        let frameCount = 0; 
        let playerHitEffectTimer = 0;
        const playerHitEffectDuration = 15; 
        const PLAYER_DEFAULT_COLOR = '#34495E'; 
        const PLAYER_HIT_COLOR = '#E74C3C'; 
        const TARGET_FPS = 60;
        const MS_PER_FRAME = 1000 / TARGET_FPS;
        let obstacleBaseRadius; 
        let powerUpObjectRadius; 

        const OBSTACLE_SHAPES = [
            { type: 'circle', sides: 0, damage: 3, color: '#FFEB3B' },
            { type: 'triangle', sides: 3, damage: 6, color: '#FFA726' },
            { type: 'square', sides: 4, damage: 10, color: '#FF7043' },
            { type: 'pentagon', sides: 5, damage: 15, color: '#F4511E' },
            { type: 'hexagon', sides: 6, damage: 20, color: '#E53935' }
        ];
        
        const POWER_UP_TYPES = {
            ABSORB: { id: 'ABSORB', name: 'Absorb', color: '#48C9B0', draw: drawAbsorbShape, duration: 20 * TARGET_FPS, minSpawn: 20 * TARGET_FPS, maxSpawn: 60 * TARGET_FPS, nextSpawnFrame: 0, onCollect: activateAbsorb, onExpire: deactivateAbsorb,
                sfxCollect: () => { if(sfxOn && soundsReady) {
                    // Nada yang dimainkan G3 (sekitar 196 Hz) atau A3 (sekitar 220Hz)
                    // Filter akan mulai terbuka tinggi (sekitar 150 * 2^4.5 Hz) dan menyapu ke bawah menuju 150 Hz.
                    absorbActivateSynth.triggerAttackRelease("G3", "0.35s", Tone.now(), 0.7); 
                }} 
            },
            SLOW: { id: 'SLOW', name: 'Slow', color: '#5499C7', draw: drawSlowShape, duration: 20 * TARGET_FPS, minSpawn: 20 * TARGET_FPS, maxSpawn: 90 * TARGET_FPS, nextSpawnFrame: 0, onCollect: activateSlow, onExpire: deactivateSlow,
                sfxCollect: () => { if(sfxOn && soundsReady) {
                    slowActivateSynth.triggerAttack("G2", Tone.now()); 
                    slowActivateSynth.frequency.rampTo("F#2", 0.5, Tone.now() + 0.1); 
                    slowActivateSynth.triggerRelease(Tone.now() + 0.6);
                }}
            },
            HEAL: { id: 'HEAL', name: 'Heal', color: '#2ECC71', draw: drawHealShape, duration: 0, minSpawn: 10 * TARGET_FPS, maxSpawn: 25 * TARGET_FPS, nextSpawnFrame: 0, onCollect: activateHeal,
                sfxCollect: () => { if(sfxOn && soundsReady) { 
                    healActivateSynth.triggerAttackRelease("C5", "0.4s", Tone.now(), 0.8); 
                    healActivateSynth.triggerAttackRelease("G5", "0.4s", Tone.now() + 0.15, 0.7); 
                }}
            },
            MINIATURIZE: { id: 'MINIATURIZE', name: 'Mini', color: '#A569BD', draw: drawMiniaturizeShape, duration: 20 * TARGET_FPS, minSpawn: 20 * TARGET_FPS, maxSpawn: 120 * TARGET_FPS, nextSpawnFrame: 0, onCollect: activateMiniaturize, onExpire: deactivateMiniaturize,
                sfxCollect: () => { if(sfxOn && soundsReady) { 
                    miniActivateSynth.triggerAttackRelease("A6", "0.05s", Tone.now(), 0.7); 
                    miniActivateSynth.triggerAttackRelease("D7", "0.05s", Tone.now() + 0.04, 0.6);
                }}
            },
            POLYMORPH: { id: 'POLYMORPH', name: 'Poly', color: '#5D6D7E', draw: drawPolymorphShape, duration: 20 * TARGET_FPS, minSpawn: 20 * TARGET_FPS, maxSpawn: 150 * TARGET_FPS, nextSpawnFrame: 0, onCollect: activatePolymorph, onExpire: deactivatePolymorph,
                sfxCollect: () => { if(sfxOn && soundsReady) {
                    polyActivateSynth.triggerAttackRelease(["C4", "Eb4", "G4", "Bb4"], "0.3s", Tone.now()); 
                }}
            }
        };
        
        function drawAbsorbShape(ctx, x, y, radius, color) { 
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = radius * 0.2;
            ctx.beginPath(); ctx.arc(x, y, radius * 0.65, -Math.PI/2, Math.PI * 1.2); ctx.stroke(); 
        }
        function drawSlowShape(ctx, x, y, radius, color) { 
            ctx.strokeStyle = color; ctx.lineWidth = Math.max(1.5, radius * 0.12);
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle)); ctx.stroke();
                for (let j = 0; j < 2; j++) {
                    const subAngle = angle + (j === 0 ? Math.PI / 6 : -Math.PI / 6); const L = radius * 0.4;
                    ctx.moveTo(x + radius * 0.6 * Math.cos(angle), y + radius * 0.6 * Math.sin(angle));
                    ctx.lineTo(x + radius * 0.6 * Math.cos(angle) + L * Math.cos(subAngle), y + radius * 0.6 * Math.sin(angle) + L * Math.sin(subAngle));
                    ctx.stroke();
                }
            }
        }
        function drawHealShape(ctx, x, y, radius, color) { 
            ctx.fillStyle = color; const barWidth = radius * 0.4; const barLength = radius * 1.4;
            ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 5;
            ctx.fillRect(x - barLength / 2, y - barWidth / 2, barLength, barWidth);
            ctx.fillRect(x - barWidth / 2, y - barLength / 2, barWidth, barLength);
            ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        }
        function drawMiniaturizeShape(ctx, x, y, radius, color) { 
            ctx.strokeStyle = color; ctx.lineWidth = Math.max(1.5, radius * 0.15);
            const L = radius * 0.8; const S = radius * 0.3; 
            const angles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]; 
            angles.forEach(baseAngle => {
                const startX = x + L * Math.cos(baseAngle); const startY = y + L * Math.sin(baseAngle);
                const endX = x + S * Math.cos(baseAngle); const endY = y + S * Math.sin(baseAngle);
                ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
                const arrowHeadSize = radius * 0.35;
                ctx.lineTo(endX + arrowHeadSize * Math.cos(baseAngle + Math.PI * 0.75), endY + arrowHeadSize * Math.sin(baseAngle + Math.PI * 0.75));
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX + arrowHeadSize * Math.cos(baseAngle - Math.PI * 0.75), endY + arrowHeadSize * Math.sin(baseAngle - Math.PI * 0.75));
                ctx.stroke();
            });
        }
        function drawPolymorphShape(ctx, x, y, radius, color) { 
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath(); ctx.arc(x - radius*0.35, y - radius*0.35, radius * 0.35, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + radius*0.3, y + radius*0.25, radius * 0.3, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2); ctx.fill();
        }

        function activateAbsorb() { activePowerUpEffects.ABSORB = { timeLeft: POWER_UP_TYPES.ABSORB.duration, totalDuration: POWER_UP_TYPES.ABSORB.duration }; }
        function deactivateAbsorb() { delete activePowerUpEffects.ABSORB; }
        let originalSpeeds = {}; 
        function activateSlow() {
            activePowerUpEffects.SLOW = { timeLeft: POWER_UP_TYPES.SLOW.duration, totalDuration: POWER_UP_TYPES.SLOW.duration };
            originalSpeeds = { minSpawn: minSpawnIntervalMs, maxSpawn: maxSpawnIntervalMs, minObs: minObstacleSpeed, maxObs: maxObstacleSpeed };
            minSpawnIntervalMs *= 1.5; maxSpawnIntervalMs *= 1.5; 
            minObstacleSpeed *= 0.5; maxObstacleSpeed *= 0.5;
            obstacles.forEach(obstacle => { obstacle.speed *= 0.5; });
        }
        function deactivateSlow() {
            minSpawnIntervalMs = originalSpeeds.minSpawn; maxSpawnIntervalMs = originalSpeeds.maxSpawn;
            minObstacleSpeed = originalSpeeds.minObs; maxObstacleSpeed = originalSpeeds.maxObs;
            delete activePowerUpEffects.SLOW;
            obstacles.forEach(obstacle => { obstacle.speed /= 0.5; });
        }
        function activateHeal() { playerHP = Math.min(100, playerHP + 25); updateUIDisplay(); }
        function activateMiniaturize() { activePowerUpEffects.MINIATURIZE = { timeLeft: POWER_UP_TYPES.MINIATURIZE.duration, totalDuration: POWER_UP_TYPES.MINIATURIZE.duration }; }
        function deactivateMiniaturize() { delete activePowerUpEffects.MINIATURIZE; }
        function activatePolymorph() { activePowerUpEffects.POLYMORPH = { timeLeft: POWER_UP_TYPES.POLYMORPH.duration, totalDuration: POWER_UP_TYPES.POLYMORPH.duration }; }
        function deactivatePolymorph() { delete activePowerUpEffects.POLYMORPH; }

        function formatTime(milliseconds) {
            if (typeof milliseconds !== 'number' || isNaN(milliseconds)) return "0,00s";
            return (milliseconds / 1000).toFixed(2).replace('.', ',') + "s";
        }

        function loadSettings() {
            sfxOn = localStorage.getItem('sfxOn') === 'false' ? false : true;
            sfxVolume = parseFloat(localStorage.getItem('sfxVolume'));
            if (isNaN(sfxVolume)) sfxVolume = 0.8;
            
            sfxToggle.textContent = sfxOn ? "ON" : "OFF";
            sfxToggle.classList.toggle('on', sfxOn);
            sfxToggle.classList.toggle('off', !sfxOn);
            sfxVolumeSlider.value = sfxVolume;
            
            applyVolumeSettings();
        }

        function saveSettings() {
            localStorage.setItem('sfxOn', sfxOn);
            localStorage.setItem('sfxVolume', sfxVolume);
        }
        
        function applyVolumeSettings() {
            if (!soundsReady) return;
            
            const sfxMasterVolumeDb = sfxOn ? Tone.gainToDb(sfxVolume) : -Infinity;
             [hitSynth, gameOverSynth, difficultyUpSynth, deleteScoreSynth, 
             absorbActivateSynth, slowActivateSynth, healActivateSynth, miniActivateSynth, polyActivateSynth]
            .forEach(synth => {
                // Periksa apakah synth dan properti volume ada sebelum Mengaturnya
                if (synth && typeof synth.volume !== 'undefined' && typeof synth.volume.value !== 'undefined') {
                     // Jika synth memiliki volume yang ditetapkan secara internal (misalnya, absorbActivateSynth.volume = -6),
                     // kita mungkin ingin sfxMasterVolumeDb ditambahkan ke itu, bukan menimpanya.
                     // Namun, untuk kesederhanaan, kita akan menimpanya, yang berarti volume internal hanyalah default awal.
                    synth.volume.value = sfxMasterVolumeDb;
                }
            });
            if(clickSynth && typeof clickSynth.volume !== 'undefined' && typeof clickSynth.volume.value !== 'undefined') {
                clickSynth.volume.value = sfxOn ? Tone.gainToDb(sfxVolume * 0.3) : -Infinity; 
            }
        }

        function initialScreenSetup() {
            mainMenuScreen.classList.add('active'); 
            settingsScreen.classList.remove('active');
            gameCanvas.style.display = 'none'; 
            document.querySelector('.ui-text-container').style.display = 'none';
            gameOverScreen.classList.remove('active'); 
            leftControl.style.display = 'none'; rightControl.style.display = 'none'; 
            activePowerUpUIDiv.innerHTML = ''; 
            const storedHighScore = parseInt(localStorage.getItem('obstacleGameHighScoreTime')) || 0;
            highScoreDisplay.textContent = `Rekor: ${formatTime(storedHighScore)}`;
            loadSettings(); 
        }

        function showGameElements() {
            gameCanvas.style.display = 'block'; 
            document.querySelector('.ui-text-container').style.display = 'flex';
            leftControl.style.display = 'block'; rightControl.style.display = 'block';
        }

        function resizeCanvas() {
            canvas.width = gameContainer.clientWidth; canvas.height = gameContainer.clientHeight;
            obstacleBaseRadius = canvas.width * 0.033; 
            powerUpObjectRadius = obstacleBaseRadius * 1.5; 
            if (!isGameOver && player) { 
                const playerSize = canvas.width * 0.052; 
                player.width = playerSize; player.height = playerSize;
                player.speed = canvas.width * 0.016; 
                player.y = canvas.height - player.height - 15; 
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                if (player.x < 0) player.x = 0;
            }
        }
        window.addEventListener('resize', resizeCanvas);
        
        function calculateNextObstacleSpawnFrame() {
            const spawnDelayMs = Math.random() * (maxSpawnIntervalMs - minSpawnIntervalMs) + minSpawnIntervalMs;
            nextObstacleSpawnFrame = frameCount + Math.round(spawnDelayMs / MS_PER_FRAME);
        }

        function initGame() {
            if (!soundsReady) { 
                initSounds().then(loadSettings).catch(err => console.error("Gagal inisialisasi suara otomatis:", err));
            } else {
                applyVolumeSettings(); 
            }
            isGameOver = false; activePowerUpEffects = {}; powerUpsOnScreen = [];
            mainMenuScreen.classList.remove('active'); settingsScreen.classList.remove('active');
            gameOverScreen.classList.remove('active'); 
            showGameElements(); resizeCanvas(); 

            const playerSize = canvas.width * 0.052; 
            player = { x: canvas.width / 2 - playerSize / 2, y: canvas.height - playerSize - 15, 
                       width: playerSize, height: playerSize, color: PLAYER_DEFAULT_COLOR, speed: canvas.width * 0.016 };
            playerVelocityX = 0; playerHP = 100; playerHitEffectTimer = 0;

            obstacles = []; currentScoreTime = 0; 
            gameStartTime = performance.now(); lastMultiplierUpdateTime = gameStartTime;
            minSpawnIntervalMs = 120; maxSpawnIntervalMs = 800; 
            minObstacleSpeed = 1.3; maxObstacleSpeed = 3.2; 

            frameCount = 0; calculateNextObstacleSpawnFrame();
            Object.values(POWER_UP_TYPES).forEach(pt => {
                pt.nextSpawnFrame = frameCount + Math.floor(Math.random() * (pt.maxSpawn - pt.minSpawn) + pt.minSpawn);
            });
            highScoreTime = parseInt(localStorage.getItem('obstacleGameHighScoreTime')) || 0;
            updateUIDisplay(); 
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop(); 
        }

        function drawPlayer() {
            ctx.fillStyle = (playerHitEffectTimer > 0) ? PLAYER_HIT_COLOR : player.color;
            ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        }

        function drawPolygon(x, y, radius, sides, color, rotation = 0) {
            ctx.beginPath(); ctx.moveTo(x + radius * Math.cos(rotation), y + radius * Math.sin(rotation));
            for (let i = 1; i < sides; i++) {
                ctx.lineTo(x + radius * Math.cos(rotation + i * 2 * Math.PI / sides), 
                           y + radius * Math.sin(rotation + i * 2 * Math.PI / sides));
            }
            ctx.closePath(); ctx.fillStyle = color; 
            ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 5; 
            ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                let { x, y, shapeDetails, rotation } = obstacle; 
                let currentRadius = obstacleBaseRadius; 
                let currentShape = shapeDetails;
                if (activePowerUpEffects.MINIATURIZE) currentRadius /= 1.5; 
                if (activePowerUpEffects.POLYMORPH) currentShape = OBSTACLE_SHAPES.find(s => s.type === 'circle');
                if (currentShape.type === 'circle') {
                    ctx.beginPath(); ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
                    ctx.fillStyle = currentShape.color; 
                    ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 5;
                    ctx.fill(); ctx.closePath(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                } else {
                    drawPolygon(x, y, currentRadius, currentShape.sides, currentShape.color, rotation);
                }
            });
        }

        function drawPowerUpsOnScreen() {
            powerUpsOnScreen.forEach(pu => {
                ctx.save(); ctx.shadowColor = 'rgba(255,255,255,0.7)'; ctx.shadowBlur = 10; 
                POWER_UP_TYPES[pu.typeId].draw(ctx, pu.x, pu.y, powerUpObjectRadius, POWER_UP_TYPES[pu.typeId].color);
                ctx.restore();
            });
        }

        function updatePlayer() {
            player.x += playerVelocityX;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (playerHitEffectTimer > 0) playerHitEffectTimer--;
        }
        
        function spawnObstacle() {
            const x = Math.random() * (canvas.width - obstacleBaseRadius * 2) + obstacleBaseRadius; 
            const y = -obstacleBaseRadius; 
            let shapeDetails = OBSTACLE_SHAPES[Math.floor(Math.random() * OBSTACLE_SHAPES.length)];
            let speed = Math.random() * (maxObstacleSpeed - minObstacleSpeed) + minObstacleSpeed;
            if (activePowerUpEffects.SLOW) speed *= 0.5; 
            obstacles.push({ x, y, speed, shapeDetails, damage: shapeDetails.damage, rotation: Math.random() * Math.PI * 2 });
        }

        function updateObstacles() {
            obstacles.forEach((obstacle, index) => {
                obstacle.y += obstacle.speed; 
                let currentRadius = obstacleBaseRadius * (activePowerUpEffects.MINIATURIZE ? (1/1.5) : 1);
                if (obstacle.y - currentRadius > canvas.height) obstacles.splice(index, 1);
            });
        }

        function spawnPowerUp(typeId) {
            const x = Math.random() * (canvas.width - powerUpObjectRadius * 2) + powerUpObjectRadius;
            const y = -powerUpObjectRadius;
            powerUpsOnScreen.push({ x, y, radius: powerUpObjectRadius, typeId, speed: 1.8 }); 
        }

        function updatePowerUpsOnScreen() {
            powerUpsOnScreen.forEach((pu, index) => {
                pu.y += pu.speed;
                if (pu.y - pu.radius > canvas.height) powerUpsOnScreen.splice(index, 1);
            });
        }

        function managePowerUpSpawning() {
            Object.values(POWER_UP_TYPES).forEach(pt => {
                if (frameCount >= pt.nextSpawnFrame) {
                    spawnPowerUp(pt.id);
                    pt.nextSpawnFrame = frameCount + Math.floor(Math.random() * (pt.maxSpawn - pt.minSpawn) + pt.minSpawn);
                }
            });
        }
        
        function updateActivePowerUpEffects() {
            for (const typeId in activePowerUpEffects) {
                if (activePowerUpEffects[typeId].timeLeft > 0) {
                    activePowerUpEffects[typeId].timeLeft--;
                } else {
                    if (POWER_UP_TYPES[typeId].onExpire) POWER_UP_TYPES[typeId].onExpire();
                }
            }
            updateActivePowerUpUIDisplay();
        }
        
        function updateActivePowerUpUIDisplay() {
            activePowerUpUIDiv.innerHTML = ''; 
            Object.entries(activePowerUpEffects).forEach(([typeId, effect]) => {
                if (effect.totalDuration > 0) { 
                    const puInfo = POWER_UP_TYPES[typeId];
                    const percentage = (effect.timeLeft / effect.totalDuration) * 100;
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'active-powerup-info';
                    infoDiv.style.borderColor = puInfo.color; 
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = `${puInfo.name}: `; 
                    const barContainer = document.createElement('div');
                    barContainer.className = 'powerup-timer-bar-container';
                    const bar = document.createElement('div');
                    bar.className = 'powerup-timer-bar';
                    bar.style.width = `${percentage}%`; bar.style.backgroundColor = puInfo.color;
                    barContainer.appendChild(bar); infoDiv.appendChild(nameSpan); infoDiv.appendChild(barContainer);
                    activePowerUpUIDiv.appendChild(infoDiv);
                }
            });
        }

        function checkCollisions() {
            obstacles.forEach((obstacle, index) => {
                let currentObsRadius = obstacleBaseRadius * (activePowerUpEffects.MINIATURIZE ? (1/1.5) : 1);
                let damageToDeal = obstacle.damage;
                if (activePowerUpEffects.ABSORB) damageToDeal /= 2;
                const distX = Math.abs(obstacle.x - player.x - player.width / 2);
                const distY = Math.abs(obstacle.y - player.y - player.height / 2);
                if (distX <= (player.width / 2 + currentObsRadius) && distY <= (player.height / 2 + currentObsRadius)) {
                     if (distX <= (player.width / 2) || distY <= (player.height / 2) || 
                        (Math.pow(distX - player.width / 2, 2) + Math.pow(distY - player.height / 2, 2) <= Math.pow(currentObsRadius, 2))) {
                        obstacles.splice(index, 1); handleCollision(damageToDeal); return; 
                    }
                }
            });
            powerUpsOnScreen.forEach((pu, index) => {
                const dx = player.x + player.width / 2 - pu.x;
                const dy = player.y + player.height / 2 - pu.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < player.width / 2 + pu.radius) { 
                    if (POWER_UP_TYPES[pu.typeId].sfxCollect && soundsReady) POWER_UP_TYPES[pu.typeId].sfxCollect();
                    POWER_UP_TYPES[pu.typeId].onCollect(); powerUpsOnScreen.splice(index, 1);
                }
            });
        }

        function handleCollision(damageAmount) {
            playerHP -= Math.round(damageAmount); playerHitEffectTimer = playerHitEffectDuration; 
            if (sfxOn && soundsReady) hitSynth.triggerAttackRelease(0.08, Tone.now()); 
            if (playerHP < 0) playerHP = 0; 
            if (playerHP <= 0) gameOver();
            updateUIDisplay();
        }

        function gameOver() {
            isGameOver = true; cancelAnimationFrame(animationFrameId); playerVelocityX = 0; 
            if (sfxOn && soundsReady) gameOverSynth.triggerAttackRelease("G2", "1.2n", Tone.now());

            Object.values(POWER_UP_TYPES).forEach(pt => { 
                if (activePowerUpEffects[pt.id] && pt.onExpire) pt.onExpire();
            });
            activePowerUpEffects = {}; 
            if (currentScoreTime > highScoreTime) {
                highScoreTime = currentScoreTime;
                localStorage.setItem('obstacleGameHighScoreTime', highScoreTime.toString()); 
            }
            finalScoreDisplay.textContent = `Waktu Bertahan: ${formatTime(currentScoreTime)}`;
            gameOverHighScoreDisplay.textContent = `Rekor Waktu: ${formatTime(highScoreTime)}`;
            gameOverScreen.classList.add('active'); 
            leftControl.style.display = 'none'; rightControl.style.display = 'none';
            activePowerUpUIDiv.innerHTML = ''; 
        }

        function updateUIDisplay() {
            scoreDisplay.textContent = `Waktu: ${formatTime(currentScoreTime)}`;
            highScoreDisplay.textContent = `Rekor: ${formatTime(highScoreTime)}`;
            const hpPercentage = (playerHP / 100) * 100;
            hpBarInner.style.width = `${hpPercentage}%`;
            if (hpPercentage > 60) hpBarInner.style.backgroundColor = '#4CAF50'; 
            else if (hpPercentage > 30) hpBarInner.style.backgroundColor = '#FFC107'; 
            else hpBarInner.style.backgroundColor = '#F44336'; 
        }

        function updateDifficulty() {
            const currentTime = performance.now();
            if ((currentTime - lastMultiplierUpdateTime) / 1000 >= 20) { 
                if (!activePowerUpEffects.SLOW) { 
                    minSpawnIntervalMs = Math.max(30, minSpawnIntervalMs / 1.1); 
                    maxSpawnIntervalMs = Math.max(100, maxSpawnIntervalMs / 1.1); 
                    if (minSpawnIntervalMs >= maxSpawnIntervalMs) maxSpawnIntervalMs = minSpawnIntervalMs + 70; 
                    minObstacleSpeed *= 1.075; maxObstacleSpeed *= 1.075; 
                    if (sfxOn && soundsReady) difficultyUpSynth.triggerAttackRelease("D6", "32n", Tone.now(), 0.6); 
                }
                lastMultiplierUpdateTime = currentTime;
            }
        }

        function gameLoop() {
            if (isGameOver) return;
            const currentTime = performance.now();
            currentScoreTime = currentTime - gameStartTime; 
            frameCount++; 
            updateDifficulty(); updateActivePowerUpEffects(); managePowerUpSpawning();
            if (frameCount >= nextObstacleSpawnFrame) { spawnObstacle(); calculateNextObstacleSpawnFrame(); }
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            updatePlayer(); updateObstacles(); updatePowerUpsOnScreen();
            drawObstacles(); drawPowerUpsOnScreen(); drawPlayer();
            checkCollisions(); updateUIDisplay(); 
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function moveLeft() { if (!isGameOver) playerVelocityX = -player.speed; }
        function moveRight() { if (!isGameOver) playerVelocityX = player.speed; }
        function stopMovement() { playerVelocityX = 0; }

        settingsButton.addEventListener('click', () => {
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.7);
            mainMenuScreen.classList.remove('active');
            settingsScreen.classList.add('active');
        });

        backToMenuButton.addEventListener('click', () => {
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.7);
            settingsScreen.classList.remove('active');
            mainMenuScreen.classList.add('active');
            saveSettings(); 
        });

        sfxToggle.addEventListener('click', () => {
            sfxOn = !sfxOn;
            sfxToggle.textContent = sfxOn ? "ON" : "OFF";
            sfxToggle.classList.toggle('on', sfxOn);
            sfxToggle.classList.toggle('off', !sfxOn);
            applyVolumeSettings();
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("D4", "16n", Tone.now(), 0.6);
        });

        sfxVolumeSlider.addEventListener('input', (e) => {
            sfxVolume = parseFloat(e.target.value);
            applyVolumeSettings();
        });
        sfxVolumeSlider.addEventListener('change', saveSettings); 
        
        deleteHighScoreButton.addEventListener('click', () => {
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("A3", "8n", Tone.now(), 0.7);
            confirmDeleteModal.style.display = 'flex';
        });

        confirmDeleteYes.addEventListener('click', () => {
            if (sfxOn && soundsReady) deleteScoreSynth.triggerAttackRelease(0.1, Tone.now());
            localStorage.removeItem('obstacleGameHighScoreTime');
            highScoreTime = 0;
            updateUIDisplay(); 
            highScoreDisplay.textContent = `Rekor: ${formatTime(highScoreTime)}`; 
            if (gameOverScreen.classList.contains('active')) {
                 gameOverHighScoreDisplay.textContent = `Rekor Waktu: ${formatTime(highScoreTime)}`;
            }
            confirmDeleteModal.style.display = 'none';
        });

        confirmDeleteNo.addEventListener('click', () => {
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C3", "16n", Tone.now(), 0.5);
            confirmDeleteModal.style.display = 'none';
        });

        startGameButton.addEventListener('click', () => {
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.8);
            else if (!soundsReady) { 
                initSounds().then(() => {
                    loadSettings(); 
                    if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.8);
                }).catch(err => console.error("Gagal inisialisasi suara saat klik:", err));
            }
            initGame();
        }); 
        restartButton.addEventListener('click', () => {
            if (sfxOn && soundsReady) clickSynth.triggerAttackRelease("C4", "8n", Tone.now(), 0.8);
            initGame();
        }); 
        leftControl.addEventListener('mousedown', moveLeft);
        leftControl.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft(); }, { passive: false }); 
        rightControl.addEventListener('mousedown', moveRight);
        rightControl.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight(); }, { passive: false });
        document.addEventListener('mouseup', stopMovement);
        document.addEventListener('touchend', stopMovement);
        document.addEventListener('touchcancel', stopMovement); 
        
        initialScreenSetup();
    </script>
</body>
</html>

